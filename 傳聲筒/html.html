<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>傳聲筒喚醒實驗</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Microsoft JhengHei', 'Courier New', sans-serif; touch-action: none; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        /* Custom UI Styling */
        .glass-panel {
            background: rgba(20, 20, 30, 0.9);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5);
            -webkit-overflow-scrolling: touch; 
        }
        
        input[type=range] {
            -webkit-appearance: none; 
            background: transparent; 
            height: 24px; 
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 20px; width: 20px;
            border-radius: 50%; background: #4ade80;
            margin-top: -8px; cursor: pointer;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px;
            background: #4b5563; border-radius: 2px;
        }

        .meter-box {
            background: rgba(0,0,0,0.6);
            border: 1px solid #333;
            padding: 4px 8px;
            border-radius: 4px;
            font-family: monospace;
            min-width: 80px;
            text-align: center;
        }
        .db-val { color: #4ade80; font-weight: bold; font-size: 1.1em; }

        .tooltip-container {
            position: relative;
            display: inline-block;
            margin-left: 6px;
            vertical-align: middle;
        }
        .info-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background-color: #6b7280;
            color: white;
            font-size: 12px;
            font-weight: bold;
            font-style: italic;
            cursor: help;
        }
        .tooltip-text {
            visibility: hidden;
            width: 200px;
            background-color: rgba(0, 0, 0, 0.95);
            color: #e5e7eb;
            text-align: left;
            border-radius: 6px;
            padding: 10px;
            position: absolute;
            z-index: 100;
            bottom: 130%;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.2s;
            font-size: 12px;
            line-height: 1.4;
            border: 1px solid #4ade80;
            pointer-events: none;
            box-shadow: 0 4px 6px rgba(0,0,0,0.5);
        }
        .tooltip-container:hover .tooltip-text, 
        .tooltip-container:active .tooltip-text {
            visibility: visible;
            opacity: 1;
        }
    </style>
</head>
<body>

    <div id="canvas-container"></div>

    <!-- Back Button -->
    <a href="../index.html" class="fixed top-6 left-6 z-[100] bg-white/90 backdrop-blur border border-slate-200 px-4 py-2 rounded-xl shadow-sm hover:bg-white transition-all flex items-center gap-2 text-slate-600 font-bold">
        <span>←</span> 離開
    </a>

    <!-- UI Overlay: Setup Phase -->
    <div id="setup-ui" class="absolute top-0 left-0 h-full w-full md:w-96 glass-panel p-6 flex flex-col justify-between z-10 transition-transform duration-500 ease-in-out transform translate-x-0 overflow-y-auto hidden">
        <div class="pb-20 md:pb-0">
            <h1 class="text-2xl md:text-3xl font-bold text-green-400 mb-2">傳聲喚醒實驗</h1>
            <p class="text-gray-400 text-xs md:text-sm mb-6">任務：配置紙杯電話裝置，確保傳輸的聲音足以喚醒小孩。</p>
            
            <div id="login-section" class="mb-8 p-4 bg-green-900/20 border border-green-500/30 rounded-xl space-y-4">
                <h3 class="text-green-500 text-xs uppercase tracking-wider">輸入班別學號</h3>
                <input type="text" id="studentInfo" placeholder="例如：1A (01)" class="w-full bg-gray-900 text-white p-3 rounded border border-gray-600 focus:border-green-500 outline-none text-sm font-bold">
                <button onclick="confirmLogin()" class="w-full bg-green-600 hover:bg-green-500 text-black font-bold py-2 rounded text-sm transition-all">
                    確認進入
                </button>
            </div>

            <div id="config-controls" class="opacity-50 pointer-events-none">
                <div class="bg-black/40 p-3 rounded border border-green-900 mb-6">
                    <h3 class="text-green-500 text-xs uppercase tracking-wider mb-1">目標資訊</h3>
                    <p class="text-gray-300 text-sm">目標狀態：<span class="text-white font-bold">熟睡中</span></p>
                    <p class="text-gray-300 text-sm">喚醒閾值：<span class="text-white font-bold">> 80 dB (固定)</span></p>
                </div>

                <div class="space-y-6">
                    <div>
                        <label class="flex items-center text-xs text-gray-400 uppercase mb-2">
                            紙杯材質
                            <div class="tooltip-container">
                                <span class="info-icon">i</span>
                                <span class="tooltip-text">【聲阻抗匹配】<br>硬材質（如金屬）能有效反射聲波進入線材；軟材質（如保麗龍）會吸收能量，造成訊號耗損。</span>
                            </div>
                        </label>
                        <select id="mat-cup" class="w-full bg-gray-800 text-white p-3 rounded border border-gray-600 focus:border-green-500 outline-none text-sm">
                            <option value="paper">紙 (標準)</option>
                            <option value="plastic">塑膠 (高反射)</option>
                            <option value="tin">金屬罐 (極佳共振)</option>
                            <option value="styrofoam">保麗龍 (高吸收)</option>
                        </select>
                    </div>

                    <div>
                        <label class="flex items-center text-xs text-gray-400 uppercase mb-2">
                            線材材質
                            <div class="tooltip-container">
                                <span class="info-icon">i</span>
                                <span class="tooltip-text">【介質密度與彈性】<br>銅線密度高且剛性好，傳導聲波效率極高；毛線結構鬆散，極易吸收振動能量。</span>
                            </div>
                        </label>
                        <select id="mat-string" class="w-full bg-gray-800 text-white p-3 rounded border border-gray-600 focus:border-green-500 outline-none text-sm">
                            <option value="cotton">棉線 (標準)</option>
                            <option value="nylon">尼龍 (彈性高)</option>
                            <option value="copper">銅線 (傳導佳)</option>
                            <option value="wool">毛線 (阻尼高)</option>
                        </select>
                    </div>

                    <div>
                        <label class="flex justify-between items-center text-xs text-gray-400 uppercase mb-1">
                            <div class="flex items-center">
                                線材張力
                                <div class="tooltip-container">
                                    <span class="info-icon">i</span>
                                    <span class="tooltip-text">【傳播介質張力】<br>張力越高，介質越緊繃，分子間傳遞振動的效率越高。鬆弛的線材無法有效傳遞縱波。</span>
                                </div>
                            </div>
                            <span id="val-tension" class="text-green-400">50%</span>
                        </label>
                        <input type="range" id="input-tension" min="0" max="100" value="50" class="w-full">
                    </div>

                    <div>
                        <label class="flex justify-between items-center text-xs text-gray-400 uppercase mb-1">
                            <div class="flex items-center">
                                線材粗細
                                <div class="tooltip-container">
                                    <span class="info-icon">i</span>
                                    <span class="tooltip-text">【截面積效應】<br>較粗的線材提供更大的截面積，減少聲波傳導時的阻力與熱耗損，適合長距離傳輸。</span>
                                </div>
                            </div>
                            <span id="val-thickness" class="text-green-400">2 mm</span>
                        </label>
                        <input type="range" id="input-thickness" min="1" max="10" value="2" step="0.5" class="w-full">
                    </div>

                    <div>
                        <label class="flex justify-between items-center text-xs text-gray-400 uppercase mb-1">
                            <div class="flex items-center">
                                鬧鐘音量
                                <div class="tooltip-container">
                                    <span class="info-icon">i</span>
                                    <span class="tooltip-text">【初始能量】<br>聲源的振幅大小。輸入能量越大，即便經過傳輸耗損，到達接收端的剩餘能量也越多。</span>
                                </div>
                            </div>
                            <span id="val-amp" class="text-green-400">80%</span>
                        </label>
                        <input type="range" id="input-amp" min="0" max="100" value="80" class="w-full">
                    </div>
                </div>
            </div>
        </div>

        <button id="btn-deploy" class="w-full bg-green-600 hover:bg-green-500 text-black font-bold py-4 rounded uppercase tracking-widest transition-colors mt-4 shadow-lg mb-6 md:mb-0 hidden">
            部署至房間
        </button>
    </div>

    <!-- UI Overlay: Game Phase & Meters (Initially Hidden) -->
    <div id="game-ui" class="absolute inset-0 opacity-0 invisible transition-all duration-500 flex flex-col justify-between p-4 md:p-8">
        
        <div class="flex justify-between w-full max-w-4xl mx-auto pointer-events-auto mt-2 md:mt-0">
            <div class="meter-box">
                <div class="text-gray-400 text-[10px] md:text-xs uppercase mb-1">來源 (發送)</div>
                <div id="meter-source" class="db-val text-sm md:text-xl">-- dB</div>
            </div>

            <div id="status-readout" class="bg-black/70 px-4 py-2 md:p-4 rounded border border-gray-600 backdrop-blur text-center h-fit mx-2">
                <div class="text-[10px] md:text-xs text-gray-400 uppercase">系統狀態</div>
                <div id="transmission-readout" class="text-green-400 font-mono text-sm md:text-xl whitespace-nowrap">準備就緒</div>
            </div>

            <div class="meter-box">
                <div class="text-gray-400 text-[10px] md:text-xs uppercase mb-1">目標 (接收)</div>
                <div id="meter-received" class="db-val text-sm md:text-xl">-- dB</div>
            </div>
        </div>

        <div class="absolute bottom-8 md:bottom-10 left-1/2 transform -translate-x-1/2 flex flex-col items-center w-full">
            <button id="btn-transmit" class="pointer-events-auto bg-red-600 hover:bg-red-500 text-white font-bold w-20 h-20 md:w-24 md:h-24 rounded-full border-4 border-red-800 shadow-[0_0_20px_rgba(220,38,38,0.7)] active:scale-95 transition-all flex items-center justify-center mb-4">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 md:h-10 md:w-10" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9" />
                </svg>
            </button>
            <button id="btn-back" class="pointer-events-auto text-gray-400 hover:text-white underline text-xs md:text-sm bg-black/60 px-4 py-2 rounded backdrop-blur-sm">
                修改配置
            </button>
        </div>
    </div>

    <div id="result-overlay" class="absolute inset-0 flex items-center justify-center bg-black/80 z-50 hidden p-4">
        <div class="text-center p-6 md:p-8 border-2 border-white/20 bg-gray-900 rounded max-w-md w-full pointer-events-auto shadow-2xl">
            <h2 id="result-title" class="text-3xl md:text-4xl font-bold mb-4 text-white">結果</h2>
            <p id="result-message" class="text-gray-300 mb-6 text-sm md:text-base leading-relaxed">分析中...</p>
            <div id="playerNameDisplay" class="mb-6 text-green-400 font-bold"></div>
            
            <div class="flex flex-col gap-4">
                <button onclick="playAgainSameUser()" class="bg-green-600 text-black px-8 py-4 rounded font-bold hover:bg-green-500 uppercase tracking-wider transition-colors">
                    同一同學再玩一局
                </button>
                <button onclick="playAgainNewUser()" class="bg-gray-700 text-white px-8 py-4 rounded font-bold hover:bg-gray-600 uppercase tracking-wider transition-colors">
                    換同學遊玩 (重新輸入)
                </button>
                <button onclick="window.location.href='../index.html'" class="text-gray-400 hover:text-white font-bold py-2 transition-all">
                    返回主目錄
                </button>
            </div>
        </div>
    </div>

    <script>
        window.addEventListener('load', () => {
            if (typeof THREE === 'undefined') {
                document.body.innerHTML = '<div style="color:white;text-align:center;padding-top:20%;font-family:sans-serif;">Error: Three.js failed to load.<br>Please check your internet connection.</div>';
                return;
            }
            initGame();
        });

        // --- Login & Student Tracking ---
        let currentUser = "";

        function confirmLogin() {
            const info = document.getElementById('studentInfo').value.trim();
            if(!info) {
                alert("請輸入班別學號！");
                return;
            }
            currentUser = info;
            document.getElementById('login-section').classList.add('hidden');
            document.getElementById('config-controls').classList.remove('opacity-50', 'pointer-events-none');
            document.getElementById('btn-deploy').classList.remove('hidden');
        }

        function playAgainSameUser() {
            resetGame();
        }

        function playAgainNewUser() {
            currentUser = "";
            document.getElementById('studentInfo').value = "";
            document.getElementById('login-section').classList.remove('hidden');
            document.getElementById('config-controls').classList.add('opacity-50', 'pointer-events-none');
            document.getElementById('btn-deploy').classList.add('hidden');
            resetGame();
        }

        function initGame() {
            // --- GAME STATE ---
            const gameState = {
                phase: 'setup',
                materials: { cup: 'paper', string: 'cotton' },
                params: { tension: 50, thickness: 2, amp: 80 },
                wakeThresholdDB: 80,
                simulating: false
            };

            const MATERIAL_STATS = {
                cups: {
                    paper: { color: 0xffffff, loss: 5 },
                    plastic: { color: 0xd92626, loss: 8 }, 
                    tin: { color: 0x888888, loss: 2 }, 
                    styrofoam: { color: 0xffffee, loss: 15 }
                },
                strings: {
                    cotton: { color: 0xdddddd, lossFactor: 1.2 },
                    nylon: { color: 0x4444ff, lossFactor: 1.0 },
                    copper: { color: 0xb87333, lossFactor: 0.5 }, 
                    wool: { color: 0xaaaaaa, lossFactor: 2.0 } 
                }
            };

            const container = document.getElementById('canvas-container');
            const scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x0a0a0a, 0.05); // Darker fog
            
            const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
            const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            // Lighting - START VISIBLE (Brighter initial state)
            const ambientLight = new THREE.AmbientLight(0x444444, 1.5); // Much brighter start
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xccccff, 1.2); // Brighter moonlight
            dirLight.position.set(-5, 10, 5);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 1024; 
            dirLight.shadow.mapSize.height = 1024;
            scene.add(dirLight);

            // Bedroom light - Starts OFF (Intensity 0)
            const warmLight = new THREE.PointLight(0xffaa00, 0, 50); // Increased range
            warmLight.position.set(3, 5, 2);
            scene.add(warmLight);

            // VISIBLE LIGHT BULB MESH (To show it turning on)
            const bulbGeo = new THREE.SphereGeometry(0.25, 16, 16);
            const bulbMat = new THREE.MeshStandardMaterial({ 
                color: 0x111111, 
                emissive: 0x000000,
                emissiveIntensity: 0
            });
            const bulbMesh = new THREE.Mesh(bulbGeo, bulbMat);
            bulbMesh.position.copy(warmLight.position);
            scene.add(bulbMesh);


            const tableGeo = new THREE.BoxGeometry(30, 0.5, 15);
            const tableMat = new THREE.MeshStandardMaterial({ color: 0x2d241b, roughness: 0.9 });
            const table = new THREE.Mesh(tableGeo, tableMat);
            table.position.set(-2, -2, 0); 
            table.receiveShadow = true;
            scene.add(table);

            // --- REDESIGNED ALARM CLOCK ---
            const alarmGroup = new THREE.Group();
            alarmGroup.position.set(-8.5, -0.2, 0); // Adjusted height
            
            const clockCaseMat = new THREE.MeshStandardMaterial({ color: 0xcc3333, metalness: 0.4, roughness: 0.3 });
            const clockMetalMat = new THREE.MeshStandardMaterial({ color: 0xdddddd, metalness: 0.9, roughness: 0.1 });

            // Main Body (Cylinder oriented Z)
            const bodyGeo = new THREE.CylinderGeometry(1.2, 1.2, 0.8, 32);
            const body = new THREE.Mesh(bodyGeo, clockCaseMat);
            body.rotation.x = Math.PI / 2; // Flat face front
            alarmGroup.add(body);

            // Face (White circle)
            const faceGeo = new THREE.CircleGeometry(1.05, 32);
            const faceMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const face = new THREE.Mesh(faceGeo, faceMat);
            face.position.z = 0.41; // Slightly in front
            alarmGroup.add(face);

            // Hands
            const handMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const hand1 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.8, 0.01), handMat);
            hand1.position.z = 0.42;
            hand1.position.y = 0.2;
            hand1.rotation.z = -0.2;
            alarmGroup.add(hand1);
            
            const hand2 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.5, 0.01), handMat);
            hand2.position.z = 0.42;
            hand2.position.x = 0.15;
            hand2.rotation.z = -1.8;
            alarmGroup.add(hand2);

            // Bells (Hemispheres on top)
            const bellGeo = new THREE.SphereGeometry(0.6, 16, 16, 0, Math.PI * 2, 0, Math.PI/2);
            const bellLeft = new THREE.Mesh(bellGeo, clockMetalMat);
            bellLeft.position.set(-0.9, 0.9, 0);
            bellLeft.rotation.z = 0.5;
            alarmGroup.add(bellLeft);

            const bellRight = new THREE.Mesh(bellGeo, clockMetalMat);
            bellRight.position.set(0.9, 0.9, 0);
            bellRight.rotation.z = -0.5;
            alarmGroup.add(bellRight);

            // Hammer
            const hammerStem = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.6), clockMetalMat);
            hammerStem.position.set(0, 1.2, 0);
            alarmGroup.add(hammerStem);
            const hammerHead = new THREE.Mesh(new THREE.SphereGeometry(0.15), clockMetalMat);
            hammerHead.position.set(0, 1.5, 0);
            alarmGroup.add(hammerHead);

            // Legs
            const legGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.6);
            const legLeft = new THREE.Mesh(legGeo, clockMetalMat);
            legLeft.position.set(-0.8, -1.2, 0);
            legLeft.rotation.z = -0.5;
            alarmGroup.add(legLeft);
            const legRight = new THREE.Mesh(legGeo, clockMetalMat);
            legRight.position.set(0.8, -1.2, 0);
            legRight.rotation.z = 0.5;
            alarmGroup.add(legRight);

            scene.add(alarmGroup);

            // Cups
            const cupGeo = new THREE.CylinderGeometry(0.8, 0.6, 1.5, 32, 1, true);
            const cupMat = new THREE.MeshStandardMaterial({ color: 0xffffff, side: THREE.DoubleSide });
            const cupBottomGeo = new THREE.CircleGeometry(0.6, 32);

            const cup1 = new THREE.Mesh(cupGeo, cupMat);
            cup1.rotation.z = Math.PI / 2; cup1.position.set(-6, -0.5, 0); cup1.castShadow = true; scene.add(cup1);
            const cup1Bottom = new THREE.Mesh(cupBottomGeo, cupMat);
            cup1Bottom.rotation.y = -Math.PI / 2; cup1Bottom.position.set(-5.25, -0.5, 0); scene.add(cup1Bottom);

            const cup2 = new THREE.Mesh(cupGeo, cupMat.clone());
            cup2.rotation.z = -Math.PI / 2; cup2.position.set(0, -0.5, 0); cup2.castShadow = true; scene.add(cup2);
            const cup2Bottom = new THREE.Mesh(cupBottomGeo, cupMat.clone());
            cup2Bottom.rotation.y = Math.PI / 2; cup2Bottom.position.set(-0.75, -0.5, 0); scene.add(cup2Bottom);

            // String
            const stringStart = new THREE.Vector3(-5.25, -0.5, 0);
            const stringEnd = new THREE.Vector3(-0.75, -0.5, 0);
            let stringMesh;

            function updateString(time = 0, amplitude = 0) {
                if(stringMesh) {
                    scene.remove(stringMesh);
                    stringMesh.geometry.dispose();
                }

                const points = [];
                const segments = 40; 
                const tensionSag = (100 - gameState.params.tension) * 0.005;

                for (let i = 0; i <= segments; i++) {
                    const t = i / segments;
                    const x = stringStart.x + (stringEnd.x - stringStart.x) * t;
                    let y = -0.5;
                    let z = 0;

                    if (!gameState.simulating) {
                        const xNorm = t * 2 - 1; 
                        y += (1 - (xNorm * xNorm)) * (-tensionSag);
                    } else {
                        const wave = Math.sin(i * 0.8 + time * 30) * (0.1 * (amplitude/100));
                        y += wave;
                    }
                    points.push(new THREE.Vector3(x, y, z));
                }

                const curve = new THREE.CatmullRomCurve3(points);
                const radius = 0.005 + (gameState.params.thickness * 0.004); 
                const geometry = new THREE.TubeGeometry(curve, segments, radius, 6, false);
                
                if(!stringMesh || !stringMesh.material) {
                    const mat = new THREE.MeshStandardMaterial({ color: 0xdddddd });
                    stringMesh = new THREE.Mesh(geometry, mat);
                } else {
                    stringMesh = new THREE.Mesh(geometry, stringMesh.material);
                }
                
                scene.add(stringMesh);
            }

            // Wall
            const wall = new THREE.Mesh(
                new THREE.BoxGeometry(0.2, 8, 8),
                new THREE.MeshPhysicalMaterial({ color: 0xdddddd, transparent: true, opacity: 0.8, transmission: 0 })
            );
            wall.position.set(-3, 1, 0);
            scene.add(wall);

            // Child
            const childGroup = new THREE.Group(); childGroup.position.set(3, -1.2, 0); scene.add(childGroup);
            const bed = new THREE.Mesh(new THREE.BoxGeometry(4, 1.5, 3), new THREE.MeshStandardMaterial({ color: 0x5d4037 })); childGroup.add(bed);
            const sheet = new THREE.Mesh(new THREE.BoxGeometry(3.8, 0.2, 2.8), new THREE.MeshStandardMaterial({ color: 0xffffff })); sheet.position.y = 0.85; childGroup.add(sheet);
            const pillow = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.3, 1.5), new THREE.MeshStandardMaterial({ color: 0xffffff })); pillow.position.set(-1.4, 1.1, 0); childGroup.add(pillow);
            
            const torsoGroup = new THREE.Group(); torsoGroup.position.set(-1.4, 1.0, 0); childGroup.add(torsoGroup);
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.4, 32, 32), new THREE.MeshStandardMaterial({ color: 0xffd1aa })); 
            head.position.y = 0.2; torsoGroup.add(head);

            const blanket = new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.4, 2.6), new THREE.MeshStandardMaterial({ color: 0x6495ed })); 
            blanket.position.set(0.6, 1.1, 0); 
            childGroup.add(blanket);

            const zzzGroup = new THREE.Group(); zzzGroup.position.set(-1.4, 2.0, 0); childGroup.add(zzzGroup);
            const bubbles = [];
            const bubbleGeo = new THREE.SphereGeometry(0.15, 6, 6);
            const bubbleMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });
            for(let i=0; i<3; i++) {
                const b = new THREE.Mesh(bubbleGeo, bubbleMat); b.position.set(i*0.3, i*0.4, 0);
                b.userData = { offset: i * 2, speed: 0.02 }; zzzGroup.add(b); bubbles.push(b);
            }

            // --- CAMERA ---
            const cameraTargets = {
                setup: { pos: new THREE.Vector3(-6, 3, 9), look: new THREE.Vector3(-4, -0.5, 0) },
                game: { pos: new THREE.Vector3(-2, 4, 14), look: new THREE.Vector3(-2, -1, 0) }
            };
            camera.position.copy(cameraTargets.setup.pos);
            camera.lookAt(cameraTargets.setup.look);

            // --- UI BINDINGS ---
            const uiElements = {
                setup: document.getElementById('setup-ui'),
                game: document.getElementById('game-ui'),
                result: document.getElementById('result-overlay'),
                readout: document.getElementById('transmission-readout'),
                meterSource: document.getElementById('meter-source'),
                meterReceived: document.getElementById('meter-received'),
                resultTitle: document.getElementById('result-title'),
                resultMsg: document.getElementById('result-message')
            };

            const inputs = {
                cup: document.getElementById('mat-cup'),
                string: document.getElementById('mat-string'),
                tension: document.getElementById('input-tension'),
                thickness: document.getElementById('input-thickness'),
                amp: document.getElementById('input-amp')
            };
            const labels = {
                tension: document.getElementById('val-tension'),
                thickness: document.getElementById('val-thickness'),
                amp: document.getElementById('val-amp')
            };

            inputs.cup.addEventListener('change', (e) => updateMaterials(e.target.value, 'cup'));
            inputs.string.addEventListener('change', (e) => updateMaterials(e.target.value, 'string'));
            inputs.tension.addEventListener('input', (e) => {
                gameState.params.tension = parseInt(e.target.value);
                labels.tension.innerText = gameState.params.tension + '%';
                if(!gameState.simulating) updateString();
            });
            inputs.thickness.addEventListener('input', (e) => {
                gameState.params.thickness = parseFloat(e.target.value);
                labels.thickness.innerText = gameState.params.thickness + ' mm';
                if(!gameState.simulating) updateString();
            });
            inputs.amp.addEventListener('input', (e) => {
                gameState.params.amp = parseInt(e.target.value);
                labels.amp.innerText = gameState.params.amp + '%';
            });

            document.getElementById('btn-deploy').addEventListener('click', () => switchMode('game'));
            document.getElementById('btn-back').addEventListener('click', () => switchMode('setup'));
            document.getElementById('btn-transmit').addEventListener('click', runSimulation);
            
            window.resetGame = function() {
                uiElements.result.classList.add('hidden');
                switchMode('setup');
            };

            function updateMaterials(val, type) {
                gameState.materials[type] = val;
                if(type === 'cup') {
                    const color = MATERIAL_STATS.cups[val].color;
                    cup1.material.color.setHex(color); cup2.material.color.setHex(color);
                    cup1Bottom.material.color.setHex(color); cup2Bottom.material.color.setHex(color);
                } else if (type === 'string') {
                    const color = MATERIAL_STATS.strings[val].color;
                    if(stringMesh) stringMesh.material.color.setHex(color);
                }
            }

            function switchMode(mode) {
                gameState.phase = mode;
                if(mode === 'game') {
                    uiElements.setup.classList.add('-translate-x-full');
                    uiElements.game.classList.remove('opacity-0', 'invisible');
                    updateMeters(0, 0); 
                } else {
                    uiElements.setup.classList.remove('-translate-x-full');
                    uiElements.game.classList.add('opacity-0', 'invisible');
                    resetChild();
                }
            }

            function resetChild() {
                gameState.simulating = false;
                torsoGroup.rotation.z = 0; 
                torsoGroup.position.y = 1.0;
                
                // LIGHT OFF
                warmLight.intensity = 0;
                bulbMat.emissiveIntensity = 0;
                ambientLight.intensity = 1.5; // Reset to new initial brightness
                dirLight.intensity = 1.2;     // Reset to new initial brightness

                zzzGroup.visible = true;
                blanket.position.x = 0.6;
                uiElements.readout.innerText = "準備就緒";
                uiElements.readout.className = "text-green-400 font-mono text-sm md:text-xl whitespace-nowrap";
                uiElements.meterSource.innerText = "-- dB";
                uiElements.meterReceived.innerText = "-- dB";
            }

            function updateMeters(source, received) {
                uiElements.meterSource.innerText = source > 0 ? source.toFixed(1) + " dB" : "-- dB";
                uiElements.meterReceived.innerText = received > 0 ? received.toFixed(1) + " dB" : "-- dB";
            }

            let audioCtx;
            function playAlarm(duration) {
                if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                if (audioCtx.state === 'suspended') audioCtx.resume();
                
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                
                osc.type = 'square'; 
                osc.frequency.setValueAtTime(800, audioCtx.currentTime); 
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                
                osc.start();
                gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                const now = audioCtx.currentTime;
                for(let i=0; i<duration * 5; i++) {
                    gain.gain.setValueAtTime(0.1, now + i*0.2);
                    gain.gain.setValueAtTime(0, now + i*0.2 + 0.1);
                }
                osc.stop(now + duration);
            }

            function runSimulation() {
                if(gameState.simulating) return;
                gameState.simulating = true;
                uiElements.readout.innerText = "訊號傳輸中...";
                uiElements.readout.className = "text-yellow-400 font-mono text-sm md:text-xl blink";

                playAlarm(2.0);
                
                // --- PHYSICS ---
                const sourceDB = 60 + (gameState.params.amp / 100 * 50);
                const cupLoss = MATERIAL_STATS.cups[gameState.materials.cup].loss * 2; 
                const stringBaseLoss = 10 * MATERIAL_STATS.strings[gameState.materials.string].lossFactor;
                const tensionLoss = (100 - gameState.params.tension) * 0.3;
                const thicknessLoss = 12 - (gameState.params.thickness * 1.5);
                const totalLoss = cupLoss + stringBaseLoss + tensionLoss + thicknessLoss;
                let receivedDB = Math.max(0, sourceDB - totalLoss);

                // --- ANIMATION LOOP ---
                let shakeFrame = 0;
                const shakeInt = setInterval(() => {
                    shakeFrame++;
                    alarmGroup.position.x = -8.5 + Math.sin(shakeFrame)*0.05;
                    if(shakeFrame > 100) {
                        clearInterval(shakeInt);
                        alarmGroup.position.x = -8.5;
                    }
                }, 20);

                let progress = 0;
                const simInterval = setInterval(() => {
                    progress += 0.05;
                    updateString(Date.now() * 0.001, receivedDB);
                    updateMeters(sourceDB, receivedDB);

                    if(progress > 2.5) { 
                        clearInterval(simInterval);
                        gameState.simulating = false;
                        
                        if(receivedDB >= gameState.wakeThresholdDB) {
                            wakeChildAnim();
                            setTimeout(() => showResult(true, sourceDB, receivedDB), 1500); 
                        } else {
                            uiElements.readout.innerText = "喚醒失敗";
                            uiElements.readout.className = "text-red-500 font-mono text-sm md:text-xl";
                            updateString();
                            setTimeout(() => showResult(false, sourceDB, receivedDB), 1000);
                        }
                    }
                }, 30);
            }

            function wakeChildAnim() {
                zzzGroup.visible = false;
                
                // LIGHT ON SEQUENCE - EXTREMELY BRIGHT
                let lightT = 0;
                const lightInt = setInterval(() => {
                    lightT += 0.05;
                    
                    // Ramp point light to blinding intensity
                    warmLight.intensity = lightT * 100; 
                    
                    // Bulb mesh glows intensely white-hot
                    bulbMat.emissive.setHex(0xffffff);
                    bulbMat.emissiveIntensity = lightT * 50; 
                    
                    // Global room brightening (Overexposed look)
                    if(ambientLight.intensity < 5.0) ambientLight.intensity += 0.2;
                    if(dirLight.intensity < 4.0) dirLight.intensity += 0.15;

                    if(lightT >= 1) clearInterval(lightInt);
                }, 30);

                let t = 0;
                const anim = () => {
                    t += 0.05;
                    if(t <= 1) {
                        torsoGroup.rotation.z = -Math.PI/2 * t;
                        torsoGroup.position.y = 1.0 + (t * 0.5);
                        blanket.position.x = 0.6 + (t * 0.5);
                        requestAnimationFrame(anim);
                    }
                };
                anim();
            }

            function showResult(success, source, received) {
                uiElements.result.classList.remove('hidden');
                document.getElementById('playerNameDisplay').innerText = currentUser;
                
                if(success) {
                    uiElements.resultTitle.innerText = "喚醒成功！";
                    uiElements.resultTitle.className = "text-3xl md:text-4xl font-bold mb-4 text-green-500";
                    uiElements.resultMsg.innerHTML = `
                        發送音量：${source.toFixed(1)} dB<br>
                        接收音量：${received.toFixed(1)} dB<br>
                        喚醒閾值：${gameState.wakeThresholdDB} dB<br>
                        <br>
                        聲音足夠大，小孩被成功叫醒了！
                    `;
                } else {
                    uiElements.resultTitle.innerText = "任務失敗";
                    uiElements.resultTitle.className = "text-3xl md:text-4xl font-bold mb-4 text-red-500";
                    uiElements.resultMsg.innerHTML = `
                        發送音量：${source.toFixed(1)} dB<br>
                        接收音量：${received.toFixed(1)} dB<br>
                        喚醒閾值：${gameState.wakeThresholdDB} dB<br>
                        <br>
                        接收端的聲音太小 (低於 80 dB)。<br>
                        試試增加線材粗細或張力，或更換為金屬材質。
                    `;
                }
            }

            function animate() {
                requestAnimationFrame(animate);

                const targetPos = gameState.phase === 'setup' ? cameraTargets.setup.pos : cameraTargets.game.pos;
                const targetLook = gameState.phase === 'setup' ? cameraTargets.setup.look : cameraTargets.game.look;
                camera.position.lerp(targetPos, 0.05);
                camera.lookAt(targetLook);

                if(zzzGroup.visible) {
                    const time = Date.now() * 0.001;
                    bubbles.forEach((b, i) => {
                        b.position.y += b.userData.speed;
                        b.position.x += Math.sin(time + i)*0.002;
                        if(b.position.y > 1.5) b.position.y = 0;
                        const s = 1 + Math.sin(time * 2 + i) * 0.2;
                        b.scale.set(s,s,s);
                    });
                }

                renderer.render(scene, camera);
            }

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            });

            // Initial Setup
            updateMaterials('paper', 'cup');
            updateMaterials('cotton', 'string');
            updateString();
            animate();
        }
    </script>
</body>
</html>