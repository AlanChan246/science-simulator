<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>æš—å½±ç¥å»Ÿ (Shadows of the Temple)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Microsoft JhengHei', sans-serif; user-select: none; }
        #game-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        
        /* Starry Background for Intro - Now Subtle Overlay */
        @keyframes twinkle { 0% { opacity: 0.3; } 50% { opacity: 1; } 100% { opacity: 0.3; } }
        
        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        .hud-top {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            pointer-events: auto;
            position: relative;
            width: 100%;
        }

        /* Exit Button */
        #btn-exit {
            position: absolute;
            left: 0;
            top: 0;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #ddd;
            color: #333;
            padding: 10px 20px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            border-radius: 12px;
            pointer-events: auto;
            z-index: 1000;
            transition: 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        #btn-exit:hover { background: #fff; transform: translateY(-2px); }

        .hud-text {
            color: rgba(255, 230, 200, 0.9);
            text-shadow: 0 0 10px #000;
            font-size: 20px;
            font-weight: bold;
            text-align: center;
            background: linear-gradient(90deg, transparent, rgba(0,0,0,0.8), transparent);
            padding: 10px 60px;
            border-top: 1px solid #444;
            border-bottom: 1px solid #444;
            letter-spacing: 2px;
        }

        #timer-display {
            position: absolute;
            right: 0;
            top: 0;
            font-size: 24px;
            font-weight: bold;
            color: #d4af37;
            background: rgba(0,0,0,0.7);
            padding: 10px 20px;
            border: 1px solid #555;
            border-radius: 4px;
            font-family: monospace;
        }

        #match-display {
            font-size: 24px;
            font-weight: bold;
            color: #ffaa00;
            display: none;
            text-shadow: 0 0 15px #ff6600;
        }

        /* Top Controls */
        #top-controls {
            display: flex;
            gap: 20px;
            justify-content: center;
            pointer-events: auto;
            margin-bottom: 10px;
        }

        .btn {
            width: 60px;
            height: 60px;
            background: rgba(30, 30, 30, 0.9);
            border: 2px solid #666;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #ddd;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            backdrop-filter: blur(5px);
        }

        .btn:active { transform: scale(0.9); }
        .btn.active { border-color: #ffaa00; background: rgba(100, 70, 20, 0.9); box-shadow: 0 0 20px #ffaa00; color: #fff; }
        
        /* Movement Controls */
        #movement-controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            pointer-events: auto;
        }

        #action-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 20px;
            pointer-events: auto;
            align-items: flex-end;
        }

        .move-btn {
            width: 70px; height: 70px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            color: white;
            font-size: 30px;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer;
            backdrop-filter: blur(4px);
            user-select: none;
        }
        .move-btn:active { background: rgba(255, 255, 255, 0.3); transform: scale(0.95); }

        .jump-btn {
            width: 80px; height: 80px;
            background: rgba(255, 200, 0, 0.2);
            border: 2px solid rgba(255, 200, 0, 0.4);
            border-radius: 50%;
            color: #ffcc00;
            font-size: 18px;
            font-weight: bold;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer;
            backdrop-filter: blur(4px);
        }
        .jump-btn:active { background: rgba(255, 200, 0, 0.4); transform: scale(0.95); }

        #message-overlay {
            position: absolute;
            top: 40%; left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 40px;
            font-weight: bold;
            text-align: center;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
            text-shadow: 0 0 30px #ffaa00;
            width: 100%;
            background: rgba(0,0,0,0.6);
            padding: 40px;
            letter-spacing: 5px;
        }

        /* Slider */
        #slider-container {
            position: absolute;
            right: 30px;
            top: 50%;
            transform: translateY(-50%);
            height: 250px;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: rgba(15, 15, 20, 0.9);
            padding: 20px 10px;
            border-radius: 30px;
            border: 1px solid #444;
            pointer-events: auto;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
        }
        
        #arm-slider {
            writing-mode: bt-lr; /* IE */
            -webkit-appearance: slider-vertical; /* WebKit */
            width: 8px;
            height: 200px;
            outline: none;
            cursor: pointer;
            accent-color: #ffaa00;
        }

        .label { font-size: 14px; color: #888; margin-bottom: 10px; writing-mode: vertical-rl; text-orientation: mixed; font-weight: bold; letter-spacing: 2px;}

        /* Drawing Modal */
        #drawing-modal {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(5, 5, 8, 0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 50;
            pointer-events: auto;
            backdrop-filter: blur(10px);
        }

        #drawing-container {
            display: flex;
            gap: 40px;
            align-items: center;
            background: rgba(20, 20, 30, 0.9);
            padding: 40px;
            border-radius: 24px;
            border: 2px solid #d4af37;
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
        }

        /* Zodiac Reference Chart */
        .zodiac-chart {
            display: grid;
            grid-template-columns: repeat(4, 1fr); /* Increased columns */
            gap: 15px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            border: 1px solid #444;
        }
        .zodiac-ref-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 15px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 15px;
            width: 130px;
            border: 1px solid rgba(255,255,255,0.2);
        }
        .zodiac-ref-canvas {
            width: 110px;
            height: 110px;
            margin-bottom: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
        }
        .zodiac-ref-emoji {
            font-size: 32px;
            margin-bottom: 5px;
        }
        .zodiac-ref-name {
            font-size: 17px;
            color: #d4af37;
            font-weight: bold;
        }

        #drawing-area-wrapper {
            position: relative;
            box-shadow: 0 0 30px rgba(255, 255, 255, 0.1);
            border: 2px solid #555;
            background: #000;
        }
        
        #drawing-canvas {
            display: block;
            cursor: crosshair;
            touch-action: none;
        }

        /* Toolbar */
        .toolbar {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
            background: #1a1a1a;
            padding: 15px 25px;
            border-radius: 8px;
            border: 1px solid #444;
            flex-wrap: wrap;
            justify-content: center;
        }

        .tool-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .tool-row {
            display: flex;
            gap: 8px;
        }

        .tool-btn {
            background: #333;
            color: #ccc;
            border: 1px solid #555;
            width: 60px; height: 60px;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: 'Microsoft JhengHei', sans-serif;
            font-weight: bold;
            padding: 5px;
        }
        .tool-btn:hover { background: #555; }
        .tool-btn.active { background: #d4af37; color: #000; border-color: #fff; }

        .tool-icon {
            font-size: 20px;
            margin-bottom: 3px;
        }
        .tool-text {
            font-size: 12px;
        }

        .tool-label {
            font-size: 12px;
            color: #888;
            letter-spacing: 1px;
            margin-top: 5px;
        }

        /* Palette */
        .palette-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 5px;
        }
        .color-swatch {
            width: 25px; height: 25px;
            border: 2px solid #444;
            border-radius: 4px;
            cursor: pointer;
        }
        .color-swatch:hover { transform: scale(1.1); }
        .color-swatch.active { border-color: #fff; box-shadow: 0 0 5px #fff; }

        input[type="range"] {
            width: 100px; accent-color: #d4af37;
        }

        .modal-controls {
            margin-top: 15px;
            display: flex;
            gap: 20px;
        }

        .modal-btn {
            padding: 12px 40px;
            font-size: 18px;
            background: #222;
            color: #aaa;
            border: 1px solid #555;
            cursor: pointer;
            border-radius: 4px;
            font-weight: bold;
            transition: 0.2s;
            font-family: 'Microsoft JhengHei', sans-serif;
        }
        .modal-btn:hover { background: #444; color: #fff; }
        .modal-btn.confirm { background: #d4af37; color: #000; border-color: #d4af37; }
        .modal-btn.confirm:hover { background: #fff; }

        /* Screens */
        .full-screen-modal {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6); /* Semi-transparent background */
            color: #d4af37;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            text-align: center;
            padding: 20px;
            backdrop-filter: blur(2px);
        }
        
        .modal-inner-border {
            border: 2px solid #d4af37;
            border-radius: 12px;
            padding: 30px;
            background: rgba(10, 10, 12, 0.85);
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.8), inset 0 0 30px rgba(0,0,0,0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            max-width: 800px;
            width: 80%;
            backdrop-filter: blur(8px);
        }

        .intro-grid {
            display: grid;
            grid-template-columns: 1.5fr 1fr;
            gap: 30px;
            text-align: left;
            width: 100%;
        }

        .intro-text h1 { 
            font-size: 48px; margin: 0 0 15px 0; letter-spacing: 5px; color: #fff; 
            text-shadow: 0 0 20px #d4af37;
            border-bottom: 2px solid #d4af37;
            padding-bottom: 5px;
            display: inline-block;
        }
        .intro-text p { 
            line-height: 1.6; font-size: 16px; color: #ccc; margin-bottom: 0;
        }
        
        .big-btn {
            padding: 12px 50px;
            font-size: 20px;
            background: linear-gradient(180deg, #d4af37, #aa8822);
            color: #000;
            border: 2px solid #fff;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.4);
            border-radius: 8px;
            letter-spacing: 3px;
            transition: 0.3s;
            font-family: 'Microsoft JhengHei', sans-serif;
            margin-top: 15px;
        }
        .big-btn:hover { 
            background: #fff; 
            box-shadow: 0 0 50px rgba(255, 255, 255, 0.8); 
            transform: scale(1.05);
        }

        #leaderboard {
            background: rgba(20, 20, 25, 0.6);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #555;
            height: fit-content;
        }
        #leaderboard h3 { color: #d4af37; margin-top: 0; border-bottom: 1px solid #555; padding-bottom: 5px; font-size: 18px; letter-spacing: 2px; text-align: center;}
        #leaderboard-list { list-style: none; padding: 0; margin: 0; text-align: left; }
        #leaderboard-list li { display: flex; justify-content: space-between; padding: 8px 0; color: #ccc; border-bottom: 1px solid #333; font-size: 16px;}
        #leaderboard-list li span:first-child { color: #fff; font-weight: bold; }

        /* Fun Fact Modal - Enhanced */
        #fact-modal, #tutorial-modal {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7); 
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 150;
            text-align: center;
            backdrop-filter: blur(5px);
        }
        
        .fact-content {
            background: rgba(20, 20, 35, 0.95);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(212, 175, 55, 0.5);
            border-radius: 20px;
            padding: 30px 40px;
            max-width: 600px; 
            box-shadow: 0 0 80px rgba(0,0,0,0.9), inset 0 0 20px rgba(212, 175, 55, 0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
            overflow: hidden;
        }

        /* Decorative glowing border */
        .fact-content::before {
            content: ''; position: absolute; top: 0; left: 0; right: 0; height: 2px;
            background: linear-gradient(90deg, transparent, #d4af37, transparent);
        }
        .fact-content::after {
            content: ''; position: absolute; bottom: 0; left: 0; right: 0; height: 2px;
            background: linear-gradient(90deg, transparent, #d4af37, transparent);
        }

        #fact-canvas {
            background: radial-gradient(circle at center, #1a1a2e 0%, #000 100%);
            border: 1px solid #444;
            border-radius: 50%;
            margin: 15px 0;
            box-shadow: 0 0 30px rgba(100, 200, 255, 0.2);
        }

        #fact-symbol {
            font-size: 80px;
            color: rgba(255, 255, 255, 0.1);
            position: absolute;
            top: 20px;
            right: 20px;
            font-weight: bold;
            pointer-events: none;
        }
        
        #tutorial-canvas {
            background: #111;
            border: 1px solid #444;
            border-radius: 8px;
            margin: 15px 0;
        }
        
        #fact-text, #tutorial-text {
            color: #eee;
            font-size: 16px;
            line-height: 1.6;
            margin-bottom: 20px;
            text-align: left;
            width: 100%;
        }

        #victory-screen { display: none; z-index: 200; background: rgba(0,0,0,0.8); }
        #white-flash {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: white; pointer-events: none; opacity: 0; z-index: 150;
            transition: opacity 2s ease-in;
        }
        
        /* Strong Magic Effect */
        #magic-flash {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, rgba(100,200,255,0.8) 0%, rgba(0,0,0,0) 70%);
            pointer-events: none; opacity: 0; z-index: 140;
            transition: opacity 0.5s ease-out;
            mix-blend-mode: screen;
        }

    </style>
</head>
<body>

    <div id="game-container"></div>
    <div id="white-flash"></div>
    <div id="magic-flash"></div>

    <div id="ui-layer">
            <div class="hud-top">
                <button id="btn-exit">é›¢é–‹</button>
                <div class="hud-text" id="match-display">å¥‘åˆåº¦: 0%</div>
                <div id="timer-display">00:00</div>
            
            <div id="top-controls">
                <div class="btn" id="btn-torch" title="åˆ‡æ›ç«æŠŠ (F)">ğŸ”¦</div>
                <div class="btn" id="btn-plate" title="èˆ‰èµ·çŸ³æ¿ (Space)">ğŸ¤š</div>
                <div class="btn" id="btn-draw" title="ç¹ªè£½ç¬¦æ–‡ (E)">âœï¸</div>
            </div>
        </div>
        
        <div id="message-overlay">å·²è§£é–</div>

        <div id="slider-container">
            <span class="label">é™°å½±å¤§å°</span>
            <input type="range" id="arm-slider" min="0.3" max="1.5" step="0.01" value="0.7">
        </div>

        <div id="movement-controls">
            <div class="move-btn" id="btn-forward">â–²</div>
            <div class="move-btn" id="btn-backward">â–¼</div>
        </div>

        <div id="action-controls">
            <div class="jump-btn" id="btn-jump">è·³èº</div>
        </div>
    </div>

    <!-- Drawing Modal -->
    <div id="drawing-modal">
        <div style="color: #d4af37; margin-bottom: 25px; font-size: 32px; letter-spacing: 5px; font-weight: bold; text-shadow: 0 0 20px rgba(212, 175, 55, 0.4);">è£½ä½œæ˜Ÿç©ºæŠ•å½±æŠ•å½±ç‰‡</div>
        
        <div id="drawing-container">
            <!-- Left: Zodiac Reference Chart -->
            <div class="zodiac-chart">
                <div style="grid-column: span 4; text-align: center; color: #888; font-size: 14px; margin-bottom: 8px; border-bottom: 1px solid #333; padding-bottom: 8px; letter-spacing: 2px;">é»ƒé“åäºŒå®®æ˜Ÿåœ–åƒè€ƒ</div>
                <div class="zodiac-ref-item" data-type="aries">
                    <canvas class="zodiac-ref-canvas" width="150" height="150"></canvas>
                    <span class="zodiac-ref-name">ç‰¡ç¾Šåº§</span>
                </div>
                <div class="zodiac-ref-item" data-type="taurus">
                    <canvas class="zodiac-ref-canvas" width="150" height="150"></canvas>
                    <span class="zodiac-ref-name">é‡‘ç‰›åº§</span>
                </div>
                <div class="zodiac-ref-item" data-type="gemini">
                    <canvas class="zodiac-ref-canvas" width="150" height="150"></canvas>
                    <span class="zodiac-ref-name">é›™å­åº§</span>
                </div>
                <div class="zodiac-ref-item" data-type="cancer">
                    <canvas class="zodiac-ref-canvas" width="150" height="150"></canvas>
                    <span class="zodiac-ref-name">å·¨èŸ¹åº§</span>
                </div>
                <div class="zodiac-ref-item" data-type="leo">
                    <canvas class="zodiac-ref-canvas" width="150" height="150"></canvas>
                    <span class="zodiac-ref-name">ç…å­åº§</span>
                </div>
                <div class="zodiac-ref-item" data-type="virgo">
                    <canvas class="zodiac-ref-canvas" width="150" height="150"></canvas>
                    <span class="zodiac-ref-name">è™•å¥³åº§</span>
                </div>
                <div class="zodiac-ref-item" data-type="libra">
                    <canvas class="zodiac-ref-canvas" width="150" height="150"></canvas>
                    <span class="zodiac-ref-name">å¤©ç§¤åº§</span>
                </div>
                <div class="zodiac-ref-item" data-type="scorpio">
                    <canvas class="zodiac-ref-canvas" width="150" height="150"></canvas>
                    <span class="zodiac-ref-name">å¤©è åº§</span>
                </div>
                <div class="zodiac-ref-item" data-type="sagittarius">
                    <canvas class="zodiac-ref-canvas" width="150" height="150"></canvas>
                    <span class="zodiac-ref-name">å°„æ‰‹åº§</span>
                </div>
                <div class="zodiac-ref-item" data-type="capricorn">
                    <canvas class="zodiac-ref-canvas" width="150" height="150"></canvas>
                    <span class="zodiac-ref-name">æ‘©ç¾¯åº§</span>
                </div>
                <div class="zodiac-ref-item" data-type="aquarius">
                    <canvas class="zodiac-ref-canvas" width="150" height="150"></canvas>
                    <span class="zodiac-ref-name">æ°´ç“¶åº§</span>
                </div>
                <div class="zodiac-ref-item" data-type="pisces">
                    <canvas class="zodiac-ref-canvas" width="150" height="150"></canvas>
                    <span class="zodiac-ref-name">é›™é­šåº§</span>
                </div>
            </div>

            <!-- Right: Drawing Area -->
            <div style="display: flex; flex-direction: column; align-items: center;">
                <div class="toolbar" style="margin-bottom: 20px; background: rgba(0,0,0,0.5);">
                    <div class="tool-group">
                        <div class="tool-row">
                            <button class="tool-btn" id="tool-undo"><span class="tool-icon">â†©ï¸</span><span class="tool-text">å¾©åŸ</span></button>
                            <button class="tool-btn" id="tool-redo"><span class="tool-icon">â†ªï¸</span><span class="tool-text">é‡åš</span></button>
                        </div>
                    </div>
                    <div class="tool-group">
                        <div class="tool-row">
                            <button class="tool-btn active" id="tool-brush"><span class="tool-icon">ğŸ–Œï¸</span><span class="tool-text">ç•«ç­†</span></button>
                            <button class="tool-btn" id="tool-eraser"><span class="tool-icon">ğŸ§¼</span><span class="tool-text">æ©¡çš®æ“¦</span></button>
                        </div>
                    </div>
                    <div class="tool-group">
                        <div class="tool-row">
                            <button class="tool-btn" id="btn-modal-clear"><span class="tool-icon">ğŸ—‘ï¸</span><span class="tool-text">é‡å¡«</span></button>
                        </div>
                    </div>
                    <div class="tool-group">
                        <input type="range" id="tool-size" min="5" max="50" value="25">
                        <div class="tool-label">ç²—ç´°</div>
                    </div>
                </div>

                <div id="drawing-area-wrapper">
                    <canvas id="guide-canvas" width="512" height="512" style="width: 400px; height: 400px; background: #000; position: absolute; top: 0; left: 0; pointer-events: none;"></canvas>
                    <canvas id="drawing-canvas" width="512" height="512" style="width: 400px; height: 400px; background: transparent; position: relative; cursor: crosshair;"></canvas>
                </div>
                
                <p style="color: #aaa; margin-top: 15px; font-size: 14px;">è«‹åƒè€ƒå·¦å´æ˜Ÿåœ–ï¼Œåœ¨<b>åœ“å½¢åŸºæº–å€åŸŸ</b>å…§ç¹ªè£½é€£ç·š</p>
                
                <div style="margin-top: 20px;">
                    <button class="tool-btn" id="btn-modal-done" style="width: 240px; height: 55px; background: #28a745; color: white; flex-direction: row; gap: 12px; font-size: 18px;">
                        <span class="tool-icon">âœ…</span> <span>ç¢ºèªè£½ä½œ</span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Tutorial Modal -->
    <div id="tutorial-modal">
        <div class="fact-content">
            <h2 style="color: #ffaa00; margin: 0 0 10px 0;">å…‰å½±ç§‘å­¸å°æ•™å®¤</h2>
            <!-- Visual Animation -->
            <canvas id="tutorial-canvas" width="400" height="180"></canvas>
            <p id="tutorial-text" style="text-align: left; font-size: 15px;">
                <span style="color:#d4af37">â˜… æŒ‘æˆ°è¦å‰‡ï¼š</span><br>
                1. <b>èªçŸ¥ï¼š</b> è§€å¯Ÿé–€ä¸Šçš„æ˜Ÿåº§æç¤ºã€‚<br>
                2. <b>æ€è€ƒï¼š</b> åœ¨è£½ä½œä»‹é¢åƒè€ƒã€Œæ˜Ÿåœ–è¡¨ã€ï¼Œæ‰¾å‡ºå°æ‡‰çš„å½¢ç‹€ã€‚<br>
                3. <b>ç¹ªåœ–ï¼š</b> è¦ªæ‰‹ç•«å‡ºè©²æ˜Ÿåº§é€£ç·šã€‚<br>
                4. <b>æŠ•å½±ï¼š</b> èª¿æ•´è·é›¢ï¼Œå°‡å½±å­æŠ•å½±åœ¨é–€ä¸Šå°é½Šï¼
            </p>
            <button id="btn-tutorial-start" class="big-btn" style="font-size: 18px; padding: 10px 40px; margin-top:0;">é–‹å§‹æŒ‘æˆ°</button>
        </div>
    </div>

    <!-- Fun Fact Modal -->
    <div id="fact-modal">
        <div class="fact-content">
            <h2 id="fact-title" style="color: #ffaa00; margin: 0 0 10px 0;">æ˜Ÿåº§çŸ¥è­˜</h2>
            <div style="position: relative;">
                <canvas id="fact-canvas" width="250" height="250"></canvas>
            </div>
            <p id="fact-text">Loading...</p>
            <button id="btn-fact-continue" class="big-btn" style="font-size: 18px; padding: 10px 40px;">ç¹¼çºŒæ¢ç´¢</button>
        </div>
    </div>

    <div id="intro" class="full-screen-modal">
        <div class="modal-inner-border">
            <div class="intro-grid">
                <div class="intro-text">
                    <h1>æš—å½±ç¥å»Ÿ</h1>
                    <p>
                        å¤äººä»¥å…‰å½±å°å°äº†é€™äº›é–€æ‰‰ï¼Œä½ éœ€è¦æ˜Ÿè¾°çš„æŒ‡å¼•ã€‚<br>
                        1. <b>æ¢ç´¢ï¼š</b> å°‹æ‰¾ç¥å»Ÿä¸­è¢«å°å°çš„æ˜Ÿåº§ä¹‹é–€ã€‚<br>
                        2. <b>æ€è€ƒ (âœï¸)ï¼š</b> æ ¹æ“šé–€ä¸Šçš„åç¨±ï¼Œç¹ªè£½æ­£ç¢ºçš„<b>é»ƒé“åäºŒå®®</b>ç¬¦è™Ÿã€‚<br>
                        3. <b>æŠ•å°„ (ğŸ¤š)ï¼š</b> åˆ©ç”¨ç«æŠŠå°‡ä½ ç¹ªè£½çš„ç¬¦è™ŸæŠ•å°„åˆ°é–€ä¸Šã€‚<br>
                        4. <b>è§£é–ï¼š</b> èª¿æ•´è·é›¢ï¼Œè®“å½±å­çš„å½¢ç‹€èˆ‡é–€ä¸Šçš„å°å°å¥‘åˆã€‚<br>
                    </p>
                    
                    <div style="margin: 20px 0; background: rgba(255,255,255,0.1); padding: 20px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.2);">
                        <label style="display: block; color: #d4af37; margin-bottom: 10px; font-weight: bold;">è¼¸å…¥ç­åˆ¥å­¸è™Ÿï¼š</label>
                        <input type="text" id="student-info" placeholder="ä¾‹å¦‚ï¼š1A (01)" style="width: 100%; padding: 12px; border-radius: 8px; border: none; background: rgba(0,0,0,0.5); color: #fff; text-align: center; font-size: 18px; margin-bottom: 10px; box-sizing: border-box;">
                    </div>

                    <button id="start-btn" class="big-btn">é€²å…¥ç¥å»Ÿ</button>
                </div>
                <div id="leaderboard">
                    <h3>æœ€é€Ÿæ¢éšªè€…</h3>
                    <ul id="leaderboard-list">
                        <li><span>1.</span> <span>--:--</span></li>
                        <li><span>2.</span> <span>--:--</span></li>
                        <li><span>3.</span> <span>--:--</span></li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <div id="victory-screen" class="full-screen-modal">
        <div class="modal-inner-border">
            <h1 style="color: #ffd700; text-shadow: 0 0 30px #ff8800;">å‚³èªªé”æˆï¼</h1>
            <p style="font-size: 20px; color: #fff;">
                ä½ å·²å¥ªå¾—è–æ¯ã€‚<br>
                ç¥å»Ÿçš„éˆé­‚å¾—ä»¥å®‰æ¯ï¼Œä½ ä¹Ÿç²å¾—äº†æ°¸æ†çš„å…‰è¼ã€‚
            </p>
            <div style="font-size: 30px; color: #d4af37; margin-bottom: 30px;" id="final-time">
                æ™‚é–“: 00:00
            </div>
            <div style="display: flex; gap: 20px; justify-content: center; width: 100%; max-width: 600px; margin: 0 auto;">
                <button id="restart-btn" class="big-btn" style="flex: 1;">åŒä¸€ä½åŒå­¸<br><span style="font-size: 14px; opacity: 0.8;">(å†ç©ä¸€å±€)</span></button>
                <button onclick="playAgainNewUser()" class="big-btn" style="flex: 1; background: #444; border-color: #666;">å¦ä¸€ä½åŒå­¸<br><span style="font-size: 14px; opacity: 0.8;">(é‡æ–°è¼¸å…¥)</span></button>
            </div>
            <button onclick="resetGameToHome()" class="big-btn" style="margin-top: 20px; background: none; border: 1px solid #555; font-size: 18px;">è¿”å›ä¸»ç›®éŒ„</button>
        </div>
    </div>

    <!-- Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- CONSTELLATION DATA ---
        const CONSTELLATIONS = {
            aries: { 
                name: "ç‰¡ç¾Šåº§ (Aries)", symbol: "â™ˆ",
                hint: "ç¥è©±ä¸­çš„é‡‘ç¾Šæ¯›å…¬ç¾Š",
                fact: "å®ƒçš„æ˜Ÿåœ–çœ‹èµ·ä¾†åƒä¸€å€‹å‘ä¸Šçš„å½é‰¤ã€‚å¸Œè‡˜ç¥è©±ä¸­ï¼Œé€™æ˜¯ä¸€éš»é•·è‘—é‡‘ç¾Šæ¯›çš„é£›å¤©ç¥ç¾Šï¼Œå®ˆè­·è‘—é»ƒé“ç¬¬ä¸€å®®ã€‚",
                lines: [[-0.4,-0.1, 0.1,0.2], [0.1,0.2, 0.3,0.25], [0.3,0.25, 0.4,0.15]] 
            },
            taurus: { 
                name: "é‡‘ç‰›åº§ (Taurus)", symbol: "â™‰",
                hint: "æ†¤æ€’çš„ç´…ç‰›çœ¼ç›",
                fact: "é‡‘ç‰›åº§å‘ˆæ˜é¡¯çš„ã€Vã€å­—å½¢ï¼Œé‚£æ˜¯å…¬ç‰›æ†¤æ€’çš„é ­éƒ¨ã€‚æœ€äº®çš„ç´…æ˜Ÿã€ç•¢å®¿äº”ã€å°±åœ¨é€™å€‹ V å­—çš„å…¶ä¸­ä¸€ç«¯å“¦ã€‚",
                lines: [[-0.3,0.3, -0.1,0.1], [-0.4,0.1, -0.1,-0.1], [-0.1,0.1, -0.05,0.02], [-0.05,0.02, 0.05,-0.02], [0.05,-0.02, -0.1,-0.1], [-0.1,-0.1, 0.1,-0.2], [0.1,-0.2, 0.3,-0.3], [0.3,-0.3, 0.35,-0.4]] 
            },
            gemini: { 
                name: "é›™å­åº§ (Gemini)", symbol: "â™Š",
                hint: "å½¢å½±ä¸é›¢çš„é›™èƒèƒ",
                fact: "æ˜Ÿåœ–ç”±å…©çµ„ä½µæ’çš„äº®æ˜Ÿé€£ç·šçµ„æˆã€‚ä»£è¡¨ä¸€å°å½¢å½±ä¸é›¢çš„é›™èƒèƒå…„å¼Ÿï¼Œåœ¨å¤œç©ºä¸­ç‰½è‘—æ‰‹ä½µæ’æ•£æ­¥ã€‚",
                lines: [[-0.1,0.3, -0.05,0.2], [-0.05,0.2, -0.2,0.1], [-0.2,0.1, -0.2,-0.1], [-0.2,-0.1, -0.15,-0.3], [-0.05,0.2, 0.0,0], [0.0,0, -0.05,-0.2], [-0.05,-0.2, -0.02,-0.4], [0.2,0.35, 0.2,0.2], [0.2,0.2, 0.35,0.2], [0.2,0.2, 0.2,0.05], [0.2,0.05, 0.25,-0.1], [0.25,-0.1, 0.35,-0.2], [0.25,-0.1, 0.15,-0.2], [0.15,-0.2, 0.1,-0.3]] 
            },
            cancer: { 
                name: "å·¨èŸ¹åº§ (Cancer)", symbol: "â™‹",
                hint: "å®³ç¾çš„å°èƒèŸ¹",
                fact: "æ˜Ÿåœ–å‘ˆç¾ã€Yã€å­—å½¢ç‹€ï¼Œåƒæ˜¯èƒèŸ¹å®³ç¾åœ°æ”¶èµ·çˆªå­ã€‚é›–ç„¶å®ƒçš„æ˜Ÿæ˜Ÿæ¯”è¼ƒæš—ï¼Œä½†ä¸­å¿ƒè—è‘—ä¸€å€‹é–ƒäº®äº®çš„æ˜Ÿåœ˜å“¦ã€‚",
                lines: [[-0.2,0.2, 0.05,0.05], [0.05,0.05, 0.2,0.1], [0.2,0.1, 0.4,0.3], [0.05,0.05, -0.1,-0.25]] 
            },
            leo: { 
                name: "ç…å­åº§ (Leo)", symbol: "â™Œ",
                hint: "å¨é¢¨å‡œå‡œçš„ç™¾ç¸ä¹‹ç‹",
                fact: "å®ƒçš„é ­éƒ¨é€£ç·šå‘ˆç¾ä¸€å€‹åå‘çš„å•è™Ÿï¼Œçœ‹èµ·ä¾†å°±åƒç…å­è¯éº—çš„é¬ƒæ¯›ã€‚é€™æ˜¯æ˜Ÿç©ºä¸­éå¸¸å®¹æ˜“è¾¨èªçš„ç™¾ç¸ä¹‹ç‹ï¼",
                lines: [[0.4,0.1, 0.2,0.25], [0.2,0.25, 0.0,0.1], [0.0,0.1, 0.1,-0.1], [0.1,-0.1, 0.3,-0.1], [0.3,-0.1, 0.3,-0.3], [0.3,-0.3, -0.4,-0.4], [-0.4,-0.4, -0.1,-0.2], [-0.1,-0.2, 0.1,-0.1]] 
            },
            virgo: { 
                name: "è™•å¥³åº§ (Virgo)", symbol: "â™",
                hint: "å¥³ç¥æ‰‹ä¸­çš„è±æ”¶éº¥ç©—",
                fact: "è¤‡é›œçš„é€£ç·šæ§‹æˆä¸€ä½å¥³ç¥å„ªé›…çš„è¼ªå»“ã€‚å¥¹æ‰‹ä¸­æ¡è‘—é–ƒäº®çš„éº¥ç©—ï¼ˆè§’å®¿ä¸€ï¼‰ï¼Œè±¡å¾µè‘—å¤§åœ°è±æ”¶èˆ‡å’Œå¹³ã€‚",
                lines: [[0.3,0.4, 0.25,0.2], [0.25,0.2, 0,0.1], [0,0.1, 0.2,0.1], [0.2,0.1, 0.2,-0.1], [0.2,-0.1, 0.3,-0.2], [0.3,-0.2, 0.0,-0.4], [0,0.1, -0.1,-0.1], [-0.1,-0.1, -0.2,-0.15], [-0.2,-0.15, -0.4,-0.3], [-0.1,-0.1, -0.1,-0.3]] 
            },
            libra: { 
                name: "å¤©ç§¤åº§ (Libra)", symbol: "â™",
                hint: "ä»£è¡¨å…¬å¹³çš„æ­£ç¾©å¤©ç§¤",
                fact: "æ˜Ÿåœ–å‘ˆç¾ä¸‰è§’å½¢çµæ§‹ï¼Œè±¡å¾µè‘—å…¬å¹³çš„æ­£ç¾©å¤©ç§¤ã€‚å®ƒæ˜¯æ˜Ÿç©ºä¸­å”¯ä¸€çš„ç„¡ç”Ÿå‘½ç‰©é«”ï¼Œä»£è¡¨å…¬å¹³èˆ‡å…¬ç¾©ã€‚",
                lines: [[0,0.3, -0.3,0.1], [-0.3,0.1, 0.3,0.05], [0.3,0.05, 0,0.3], [-0.3,0.1, -0.1,-0.1], [-0.1,-0.1, -0.1,-0.4], [0.3,0.05, 0.35,-0.2], [0.35,-0.2, 0.45,-0.2]] 
            },
            scorpio: { 
                name: "å¤©è åº§ (Scorpius)", symbol: "â™",
                hint: "éŠ€æ²³ä¸­å¿ƒçš„ç´…è‰²æ¯’è ",
                fact: "æ˜Ÿåœ–å°¾éƒ¨å‘ˆç¾æ˜é¡¯çš„é‰¤ç‹€ã€Sã€å½¢ï¼Œå°±åƒä¸€éš»å¨é¢¨çš„è å­ã€‚ä¸­å¿ƒçš„ç´…æ˜Ÿã€å¿ƒå®¿äºŒã€æ­£æ˜¯è å­çš„å¿ƒè‡Ÿã€‚",
                lines: [[-0.1,0.2, 0.0,0.4], [-0.1,0.2, -0.3,0.25], [-0.1,0.2, -0.2,0.05], [-0.1,0.2, 0.0,0.05], [0.0,0.05, 0.1,-0.1], [0.1,-0.1, 0.1,-0.3], [0.1,-0.3, 0.25,-0.4], [0.25,-0.4, 0.4,-0.35], [0.4,-0.35, 0.45,-0.2], [0.45,-0.2, 0.35,-0.1]] 
            },
            sagittarius: { 
                name: "å°„æ‰‹åº§ (Sagittarius)", symbol: "â™",
                hint: "éŠ€æ²³ç³»ä¸­å¿ƒçš„ç¥ç§˜èŒ¶å£º",
                fact: "å°„æ‰‹åº§çš„ä¸­å¿ƒéƒ¨åˆ†é€£æˆäº†ä¸€å€‹æ˜é¡¯çš„ã€èŒ¶å£ºã€å½¢ç‹€ã€‚å‚³èªªéŠ€æ²³å°±æ˜¯å¾é€™å€‹ç¥å¥‡å£ºå˜´ä¸­å™´å‡ºçš„è’¸æ±½å“¦ï¼",
                lines: [[-0.2,0.3, -0.1,0.1], [-0.1,0.1, 0,0.1], [0,0.1, 0.1,0], [0.1,0, 0.2,0.2], [0.1,0, 0.1,-0.2], [0.1,-0.2, 0.2,-0.3], [0.1,-0.2, 0.3,-0.1], [-0.1,0.1, -0.2,0.05], [-0.2,0.05, -0.3,0.15], [-0.3,0.15, -0.4,0], [-0.4,0, -0.35,-0.2], [-0.35,-0.2, -0.3,-0.35], [-0.35,-0.2, -0.2,-0.2]] 
            },
            capricorn: { 
                name: "æ‘©ç¾¯åº§ (Capricornus)", symbol: "â™‘",
                hint: "åŠç¾ŠåŠé­šçš„éŸ³æ¨‚ç‰§ç¥",
                fact: "é€£ç·šæ§‹æˆä¸€å€‹å¤§ä¸‰è§’å½¢è¼ªå»“ã€‚é€™æ˜¯ä¸€å€‹å¥‡ç‰¹çš„ç”Ÿç‰©ï¼šä¸ŠåŠèº«æ˜¯å±±ç¾Šï¼Œä¸‹åŠèº«å»æ˜¯é­šå°¾å·´ï¼Œæ˜¯ä¸€ä½æ“…é•·éŸ³æ¨‚çš„ç‰§ç¥ã€‚",
                lines: [[0.3,0.3, 0.25,0.15], [0.25,0.15, 0.2,-0.25], [0.2,-0.25, 0.1,-0.3], [0.1,-0.3, -0.1,-0.25], [-0.1,-0.25, -0.2,-0.15], [-0.2,-0.15, -0.3,-0.05], [-0.3,-0.05, -0.2,0], [-0.2,0, 0,0.1], [0,0.1, 0.25,0.15]] 
            },
            aquarius: { 
                name: "æ°´ç“¶åº§ (Aquarius)", symbol: "â™’",
                hint: "æ™ºæ…§ä¹‹æ°´çš„å‚¾å€’è€…",
                fact: "æ˜Ÿåœ–ç”±å¹¾æ¢ç™¼æ•£çš„é€£ç·šçµ„æˆï¼Œåƒæ˜¯å¾æ°´ç“¶ä¸­å‚¾å€’è€Œå‡ºçš„æ™ºæ…§ä¹‹æ°´ï¼Œæ»‹æ½¤è‘—æ•´ç‰‡å®‡å®™æ˜Ÿç©ºã€‚",
                lines: [[-0.2,0.3, -0.3,0.2], [-0.3,0.2, -0.4,0], [-0.4,0, -0.1,-0.1], [-0.1,-0.1, -0.05,-0.2], [-0.05,-0.2, 0,-0.4], [-0.2,0.3, -0.1,0.35], [-0.1,0.35, 0,0.35], [0,0.35, 0.1,0.15], [0.1,0.15, 0.25,0], [0,0.35, 0.4,0.1]] 
            },
            pisces: { 
                name: "é›™é­šåº§ (Pisces)", symbol: "â™“",
                hint: "ç¹©ç´¢ç¹«è‘—çš„å…©æ¢å°é­š",
                fact: "å…©çµ„é€£ç·šåœ¨åº•éƒ¨äº¤åŒ¯æˆä¸€å€‹å¤§ã€Vã€å­—å½¢ã€‚ä»£è¡¨å…©æ¢è¢«çµ²å¸¶ç¹«åœ¨ä¸€èµ·çš„å°é­šï¼Œæœè‘—ä¸åŒæ–¹å‘åŠªåŠ›æ¸¸å‹•ã€‚",
                lines: [[-0.4,-0.4, -0.35,-0.2], [-0.35,-0.2, -0.32,0.0], [-0.32,0.0, -0.35,0.2], [-0.35,0.2, -0.4,0.4], [-0.4,-0.4, -0.2,-0.35], [-0.2,-0.35, 0.0,-0.25], [0.0,-0.25, 0.2,-0.15], [0.2,-0.15, 0.35,-0.2], [0.35,-0.2, 0.5,-0.1], [0.5,-0.1, 0.5,0.1], [0.5,0.1, 0.35,0.2], [0.35,0.2, 0.2,-0.15]] 
            }
        };

        function initZodiacChart() {
            const items = document.querySelectorAll('.zodiac-ref-item');
            items.forEach(item => {
                const type = item.getAttribute('data-type');
                const canvas = item.querySelector('.zodiac-ref-canvas');
                const ctx = canvas.getContext('2d');
                const lines = CONSTELLATIONS[type].lines;
                
                ctx.clearRect(0, 0, 150, 150);
                
                ctx.strokeStyle = "#ffffff";
                ctx.lineWidth = 2.5; // Back to normal thickness
                ctx.lineCap = "round";
                ctx.lineJoin = "round";
                const scale = 100; // Increased scale to make the map larger
                const offX = 75;
                const offY = 75;
                
                ctx.beginPath();
                lines.forEach(line => {
                    ctx.moveTo(line[0]*scale + offX, -line[1]*scale + offY); 
                    ctx.lineTo(line[2]*scale + offX, -line[3]*scale + offY);
                });
                ctx.stroke();

                // Draw dots
                ctx.fillStyle = "#ffffff";
                lines.forEach(line => {
                    [0, 2].forEach(idx => {
                        ctx.beginPath();
                        ctx.arc(line[idx]*scale + offX, -line[idx+1]*scale + offY, 3, 0, Math.PI*2);
                        ctx.fill();
                    });
                });
            });
        }
        
        // Call it after constellations are defined
        initZodiacChart();

        function getRandomLevels() {
            const keys = Object.keys(CONSTELLATIONS);
            const shuffled = keys.sort(() => 0.5 - Math.random());
            return shuffled.slice(0, 3).map(k => ({ 
                type: k, 
                name: CONSTELLATIONS[k].name, 
                fact: CONSTELLATIONS[k].fact, 
                lines: CONSTELLATIONS[k].lines,
                symbol: CONSTELLATIONS[k].symbol
            }));
        }

        // --- GAME STATE ---
        const state = {
            torchOn: true,
            plateUp: false,
            drawingMode: false,
            armExtension: 0.7, 
            currentLevel: 0, 
            moveForward: false,
            moveBackward: false,
            jumping: false,
            levelTransition: false, 
            velocity: new THREE.Vector3(),
            onGround: true,
            haunting: false,
            torchFlameParticles: null,
            startTime: 0,
            gameActive: false,
            levitating: false, 
            mice: [],
            ghosts: [],
            grailMesh: null,
            levels: [], 
            levelZ: [-12, -26, -40, -60],
            magicParticles: []
        };

        const drawingState = {
            mode: 'brush', 
            color: '#b41414',
            size: 25,
            history: [],
            historyStep: -1
        };

        // --- LEADERBOARD & TIME ---
        function formatTime(ms) {
            const totalSec = Math.floor(ms / 1000);
            const m = Math.floor(totalSec / 60);
            const s = totalSec % 60;
            return `${m}:${s < 10 ? '0'+s : s}`;
        }

        function updateTimer() {
            if (!state.gameActive || state.currentLevel >= 3) return;
            const elapsed = Date.now() - state.startTime;
            document.getElementById('timer-display').innerText = formatTime(elapsed);
        }

        function loadLeaderboard() {
            try {
                const raw = localStorage.getItem('shadows_leaderboard');
                let times = raw ? JSON.parse(raw) : [];
                const list = document.getElementById('leaderboard-list');
                list.innerHTML = '';
                for(let i=0; i<3; i++) {
                    const t = times[i] ? formatTime(times[i]) : '--:--';
                    const li = document.createElement('li');
                    li.innerHTML = `<span>${i+1}.</span> <span>${t}</span>`;
                    list.appendChild(li);
                }
                return times;
            } catch (e) {
                console.error("Leaderboard load failed", e);
                return [];
            }
        }

        function saveTime(ms) {
            try {
                let times = loadLeaderboard();
                times.push(ms);
                times.sort((a,b) => a - b);
                times = times.slice(0, 3);
                localStorage.setItem('shadows_leaderboard', JSON.stringify(times));
                loadLeaderboard();
            } catch (e) {
                console.error("Leaderboard save failed", e);
            }
        }

        function resetGame() {
            softReset();
        }
        
        function softReset() {
            // Reset State
            state.torchOn = true;
            state.plateUp = false;
            state.drawingMode = false;
            state.armExtension = 0.7;
            state.currentLevel = 0;
            state.moveForward = false;
            state.moveBackward = false;
            state.jumping = false;
            state.levelTransition = false;
            state.onGround = true;
            state.gameActive = false;
            state.levitating = false;
            state.grailMesh = null;
            
            // Clear Entities
            state.mice.forEach(m => scene.remove(m)); state.mice = [];
            state.ghosts.forEach(g => scene.remove(g)); state.ghosts = [];
            
            // Comprehensive Door Cleanup
            const doorsToRemove = [];
            scene.traverse(obj => { if(obj.userData && obj.userData.isDoorGroup) doorsToRemove.push(obj); });
            doorsToRemove.forEach(d => scene.remove(d));
            currentDoorObj = null;
            
            // Rebuild Scene parts
            const oldTreasure = scene.children.find(c => c.userData && c.userData.isTreasureGroup);
            if(oldTreasure) scene.remove(oldTreasure);
            
            // Reset Camera
            camera.position.set(0, 1.7, 0);
            camera.rotation.set(0,0,0);
            camRot = {x:0, y:0};
            
            // UI Reset
            document.getElementById('victory-screen').style.display = 'none';
            document.getElementById('intro').style.display = 'flex';
            document.getElementById('white-flash').style.opacity = 0;
            document.getElementById('match-display').style.display = 'none';
            document.getElementById('match-display').innerText = 'å¥‘åˆåº¦: 0%';
            document.getElementById('timer-display').innerText = '00:00';
            
            // Reset Tools
            clearCanvas(false);
            toggleTorch(true);
            
            loadLeaderboard(); // Refresh scores
        }

        loadLeaderboard();

        // --- THREE.JS SETUP ---
        const container = document.getElementById('game-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x000000, 5, 40); 
        scene.background = new THREE.Color(0x000000);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 1.7, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        container.appendChild(renderer.domElement);

        // --- AUDIO ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            const t = audioCtx.currentTime;

            if (type === 'click') {
                osc.type = 'sine'; osc.frequency.setValueAtTime(800, t);
                osc.frequency.exponentialRampToValueAtTime(300, t + 0.1);
                gain.gain.setValueAtTime(0.05, t); gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
                osc.start(); osc.stop(t + 0.1);
            } else if (type === 'jump') {
                osc.type = 'square'; osc.frequency.setValueAtTime(150, t);
                osc.frequency.linearRampToValueAtTime(100, t + 0.2);
                gain.gain.setValueAtTime(0.1, t); gain.gain.linearRampToValueAtTime(0, t + 0.2);
                osc.start(); osc.stop(t + 0.2);
            } else if (type === 'unlock') {
                const osc2 = audioCtx.createOscillator();
                const gain2 = audioCtx.createGain();
                osc2.connect(gain2); gain2.connect(audioCtx.destination);
                osc.type = 'sine'; osc.frequency.setValueAtTime(400, t); osc.frequency.exponentialRampToValueAtTime(800, t + 0.5);
                gain.gain.setValueAtTime(0.2, t); gain.gain.linearRampToValueAtTime(0, t + 1.5);
                osc2.type = 'triangle'; osc2.frequency.setValueAtTime(600, t); osc2.frequency.exponentialRampToValueAtTime(1200, t + 0.5);
                gain2.gain.setValueAtTime(0.1, t); gain2.gain.linearRampToValueAtTime(0, t + 1.5);
                osc.start(); osc.stop(t + 1.5);
                osc2.start(); osc2.stop(t + 1.5);
            } else if (type === 'win') {
                osc.type = 'sine'; osc.frequency.setValueAtTime(400, t);
                osc.frequency.linearRampToValueAtTime(800, t + 0.5);
                gain.gain.setValueAtTime(0.3, t); gain.gain.linearRampToValueAtTime(0, t + 3.0);
                osc.start(); osc.stop(t + 3.0);
            } else if (type === 'torch_off') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, t);
                osc.frequency.exponentialRampToValueAtTime(10, t + 0.3);
                gain.gain.setValueAtTime(0.2, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.3);
                osc.start(); osc.stop(t+0.3);
            } else if (type === 'boom') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(100, t);
                osc.frequency.exponentialRampToValueAtTime(10, t + 0.5);
                gain.gain.setValueAtTime(0.3, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.5);
                osc.start(); osc.stop(t+0.5);
            } else if (type === 'slide') {
                // Subtle slide sound
            }
        }

        // --- DRAWING ---
        const drawCanvas = document.getElementById('drawing-canvas');
        const ctx = drawCanvas.getContext('2d');
        const drawingTexture = new THREE.CanvasTexture(drawCanvas);
        
        function updateTexture() { drawingTexture.needsUpdate = true; }

        function saveHistory() {
            drawingState.historyStep++;
            if (drawingState.historyStep < drawingState.history.length) drawingState.history.length = drawingState.historyStep;
            drawingState.history.push(drawCanvas.toDataURL());
        }

        function restoreHistory() {
            if (drawingState.historyStep < 0) { clearCanvas(false); return; }
            const img = new Image();
            img.src = drawingState.history[drawingState.historyStep];
            img.onload = () => {
                ctx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
                ctx.globalCompositeOperation = 'source-over';
                ctx.drawImage(img, 0, 0);
                updateTexture();
            };
        }

        function clearCanvas(shouldSave = true) {
            ctx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
            updateTexture();
            if (shouldSave) { drawingState.history = []; drawingState.historyStep = -1; saveHistory(); }
        }
        
        saveHistory(); 

        let isDrawing = false;
        let lastX = 0; let lastY = 0;

        function getCanvasPos(evt) {
            const rect = drawCanvas.getBoundingClientRect();
            const clientX = evt.touches ? evt.touches[0].clientX : evt.clientX;
            const clientY = evt.touches ? evt.touches[0].clientY : evt.clientY;
            return { x: (clientX - rect.left) / rect.width * 512, y: (clientY - rect.top) / rect.height * 512 };
        }

        function startDraw(e) { isDrawing = true; const pos = getCanvasPos(e); lastX = pos.x; lastY = pos.y; }

        function moveDraw(e) {
            if (!isDrawing) return;
            e.preventDefault(); 
            const pos = getCanvasPos(e);
            ctx.lineWidth = drawingState.size; 
            ctx.lineCap = "round";
            ctx.lineJoin = "round";
            if (drawingState.mode === 'eraser') {
                ctx.globalCompositeOperation = 'destination-out';
                ctx.strokeStyle = "rgba(0,0,0,1)";
            } else {
                ctx.globalCompositeOperation = 'source-over';
                ctx.strokeStyle = drawingState.color;
            }
            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(pos.x, pos.y);
            ctx.stroke();
            lastX = pos.x; lastY = pos.y;
            updateTexture();
        }

        function endDraw() { if(isDrawing) { isDrawing = false; saveHistory(); } }

        drawCanvas.addEventListener('mousedown', startDraw);
        drawCanvas.addEventListener('mousemove', moveDraw);
        drawCanvas.addEventListener('mouseup', endDraw);
        drawCanvas.addEventListener('touchstart', startDraw);
        drawCanvas.addEventListener('touchmove', moveDraw);
        drawCanvas.addEventListener('touchend', endDraw);

        // UI Listeners
        document.getElementById('tool-brush').addEventListener('click', () => {
            drawingState.mode = 'brush';
            document.getElementById('tool-brush').classList.add('active');
            document.getElementById('tool-eraser').classList.remove('active');
        });
        document.getElementById('tool-eraser').addEventListener('click', () => {
            drawingState.mode = 'eraser';
            document.getElementById('tool-eraser').classList.add('active');
            document.getElementById('tool-brush').classList.remove('active');
        });
        document.querySelectorAll('.color-swatch').forEach(swatch => {
            swatch.addEventListener('click', (e) => {
                drawingState.color = e.target.getAttribute('data-color');
                drawingState.mode = 'brush'; 
                document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
                e.target.classList.add('active');
                document.getElementById('tool-brush').classList.add('active');
                document.getElementById('tool-eraser').classList.remove('active');
            });
        });
        document.getElementById('tool-size').addEventListener('input', (e) => { drawingState.size = parseInt(e.target.value); });
        document.getElementById('tool-undo').addEventListener('click', () => { if (drawingState.historyStep > 0) { drawingState.historyStep--; restoreHistory(); } else if (drawingState.historyStep === 0) { drawingState.historyStep = -1; ctx.clearRect(0,0,512,512); updateTexture(); } });
        document.getElementById('tool-redo').addEventListener('click', () => { if (drawingState.historyStep < drawingState.history.length - 1) { drawingState.historyStep++; restoreHistory(); } });
        
        // --- Reference Shape ---
        const refCanvas = document.createElement('canvas');
        refCanvas.width = 512; refCanvas.height = 512;
        const refCtx = refCanvas.getContext('2d');
        let refData = null;

        function prepareRefData(runeType) {
            const data = CONSTELLATIONS[runeType];
            const lines = data.lines;
            
            refCtx.clearRect(0, 0, 512, 512);
            refCtx.fillStyle = "white";
            
            // Draw lines for validation - Adjusted for 10% easier experience
            if (lines && lines.length > 0) {
                refCtx.strokeStyle = "white";
                refCtx.lineWidth = 55; // Increased from 45 for 10% easier success
                refCtx.lineCap = "round";
                refCtx.lineJoin = "round";
                const scale = 320; 
                const offX = 256;
                const offY = 256;
                
                refCtx.beginPath();
                lines.forEach(line => {
                    refCtx.moveTo(line[0]*scale + offX, -line[1]*scale + offY); 
                    refCtx.lineTo(line[2]*scale + offX, -line[3]*scale + offY);
                });
                refCtx.stroke();
            }
            
            refData = refCtx.getImageData(0, 0, 512, 512).data;
            
            state.refPixelCount = 0;
            for(let y=0; y<512; y+=10) {
                for(let x=0; x<512; x+=10) {
                    if(refData[(y * 512 + x) * 4] > 128) state.refPixelCount++;
                }
            }
        }

        const factCanvas = document.getElementById('fact-canvas');
        const factCtx = factCanvas.getContext('2d');

        function drawConstellation(context, width, height, lines, color, isStunning, symbol, hideDetails = false) {
            if (!context) return;
            context.clearRect(0, 0, width, height);
            
            if (isStunning) {
                // Nebula Background
                const gradient = context.createRadialGradient(width/2, height/2, 20, width/2, height/2, width/1.2);
                gradient.addColorStop(0, '#2a2a4e');
                gradient.addColorStop(0.6, '#1a1a2e');
                gradient.addColorStop(1, '#000000');
                context.fillStyle = gradient;
                context.fillRect(0,0,width,height);

                // Background Stars
                context.fillStyle = "rgba(255, 255, 255, 0.4)";
                for(let i=0; i<50; i++) {
                    context.beginPath();
                    context.arc(Math.random()*width, Math.random()*height, Math.random()*1.5, 0, Math.PI*2);
                    context.fill();
                }

                // Draw Symbol
                if (symbol) {
                    context.save();
                    context.font = `${width * 0.7}px "Arial"`; // No bold
                    context.textAlign = "center";
                    context.textBaseline = "middle";
                    context.fillStyle = "rgba(255, 255, 255, 1.0)";
                    context.fillText(symbol, width/2, height/2);
                    context.restore();
                }
            }

            if (hideDetails) return; // Skip lines and stars

            context.strokeStyle = color; 
            context.lineWidth = isStunning ? 4 : 3; 
            context.lineCap = "round";
            context.shadowBlur = isStunning ? 15 : 0;
            context.shadowColor = color;
            context.beginPath();
            
            // Centering logic
            const scale = width / 2.5; 
            const offX = width / 2;
            const offY = height / 2;
            
            lines.forEach(line => {
                context.moveTo(line[0]*scale + offX, -line[1]*scale + offY); 
                context.lineTo(line[2]*scale + offX, -line[3]*scale + offY);
            });
            context.stroke();
            context.shadowBlur = 0; // Reset
            
            // Draw Stars
            context.fillStyle = "#fff";
            lines.forEach(line => {
                [0, 2].forEach(idx => {
                    context.beginPath();
                    const x = line[idx]*scale + offX;
                    const y = -line[idx+1]*scale + offY;
                    context.arc(x, y, isStunning ? 5 : 4, 0, Math.PI*2);
                    context.fill();
                    
                    if (isStunning) {
                         context.shadowBlur = 10;
                         context.shadowColor = "#fff";
                         context.strokeStyle = "rgba(255,255,255,0.5)";
                         context.lineWidth = 1;
                         context.stroke();
                         context.shadowBlur = 0;
                    }
                });
            });
        }

        function updateReferenceShape() {
            const guideCanvas = document.getElementById('guide-canvas');
            const gCtx = guideCanvas.getContext('2d');
            
            gCtx.clearRect(0, 0, 512, 512);
            
            // Draw a generic "Safe Zone" circle
            // Increased visibility for iPad
            gCtx.strokeStyle = "rgba(255, 212, 55, 0.4)"; // Stronger gold
            gCtx.lineWidth = 3;
            gCtx.setLineDash([15, 10]); // Longer dashes
            
            const offX = 256;
            const offY = 256;
            const radius = 180; 
            
            gCtx.beginPath();
            gCtx.arc(offX, offY, radius, 0, Math.PI * 2);
            gCtx.stroke();
            
            // Draw center crosshair - Brighter
            gCtx.setLineDash([]);
            gCtx.strokeStyle = "rgba(255, 255, 255, 0.2)";
            gCtx.beginPath();
            gCtx.moveTo(offX - 30, offY); gCtx.lineTo(offX + 30, offY);
            gCtx.moveTo(offX, offY - 30); gCtx.lineTo(offX, offY + 30);
            gCtx.stroke();
        }
        
        // --- TUTORIAL ANIMATION ---
        const tutCanvas = document.getElementById('tutorial-canvas');
        const tutCtx = tutCanvas.getContext('2d');
        let tutFrame = 0;
        
        function animateTutorial() {
            if(document.getElementById('tutorial-modal').style.display === 'none') return;
            requestAnimationFrame(animateTutorial);
            tutFrame++;
            
            tutCtx.clearRect(0, 0, tutCanvas.width, tutCanvas.height);
            
            const centerX = tutCanvas.width / 2;
            const startX = 50; 
            const endX = 350;
            const lightX = 30;
            const wallX = 370;
            const centerY = tutCanvas.height / 2;
            
            // Animate Plate
            const plateX = 120 + Math.sin(tutFrame * 0.05) * 60; 
            
            // Draw Rays
            tutCtx.beginPath();
            tutCtx.moveTo(lightX, centerY);
            
            // Dot position
            const dotY = centerY; // Center for simplicity of rays
            const dotSize = 4;
            
            // Top Ray through paper top edge
            // Paper is frame, so we project the frame edges
            const frameHeight = 50;
            
            // Top Frame Edge
            const slopeTop = (centerY - frameHeight/2 - centerY) / (plateX - lightX);
            const wallYTop = centerY + slopeTop * (wallX - lightX);
            tutCtx.lineTo(wallX, wallYTop);
            
            // Bottom Frame Edge
            const slopeBot = (centerY + frameHeight/2 - centerY) / (plateX - lightX);
            const wallYBot = centerY + slopeBot * (wallX - lightX);
            tutCtx.lineTo(wallX, wallYBot);
            
            tutCtx.fillStyle = "rgba(255, 200, 50, 0.05)";
            tutCtx.fill();
            tutCtx.strokeStyle = "rgba(255, 200, 50, 0.2)";
            tutCtx.stroke();
            
            // Draw Light Source
            tutCtx.beginPath();
            tutCtx.arc(lightX, centerY, 10, 0, Math.PI*2);
            tutCtx.fillStyle = "#ffaa00";
            tutCtx.fill();
            tutCtx.shadowBlur = 20; tutCtx.shadowColor = "#ffaa00";
            tutCtx.stroke();
            tutCtx.shadowBlur = 0;
            
            // Draw Paper Frame (Thin White Rect)
            tutCtx.strokeStyle = "#fff";
            tutCtx.lineWidth = 2;
            tutCtx.strokeRect(plateX, centerY - frameHeight/2, 2, frameHeight);
            
            // Draw Dot on Paper
            tutCtx.fillStyle = "#f00";
            tutCtx.beginPath();
            tutCtx.arc(plateX, centerY + 10, dotSize, 0, Math.PI*2); // Dot slightly offset
            tutCtx.fill();
            
            // Draw Dot Shadow on Wall
            // Calculate projection
            const dotOffset = 10;
            const slopeDot = (centerY + dotOffset - centerY) / (plateX - lightX);
            const wallDotY = centerY + slopeDot * (wallX - lightX);
            const mag = (wallX - lightX) / (plateX - lightX);
            
            // Draw Wall
            tutCtx.fillStyle = "#333";
            tutCtx.fillRect(wallX, 20, 10, 140);
            
            // Draw Shadow of Frame
            const shadowHeight = wallYBot - wallYTop;
            tutCtx.fillStyle = "rgba(0,0,0,0.5)"; // Shadow is dark
            tutCtx.fillRect(wallX, wallYTop, 10, shadowHeight);
            
            // Draw Shadow of Dot
            tutCtx.fillStyle = "#000"; // Dot shadow is darker
            tutCtx.beginPath();
            tutCtx.arc(wallX + 5, wallDotY, dotSize * mag, 0, Math.PI*2);
            tutCtx.fill();
            
            // Text Labels
            tutCtx.fillStyle = "#aaa";
            tutCtx.font = "12px sans-serif";
            tutCtx.fillText("å…‰æº", lightX - 10, centerY + 40);
            tutCtx.fillText("ç´™å¡(é»)", plateX - 10, centerY + 60);
            tutCtx.fillText("ç‰†å£(å½±)", wallX - 20, 175);
        }

        // --- ENTITIES ---
        function createMouseMesh() {
            const group = new THREE.Group();
            const bodyGeo = new THREE.SphereGeometry(0.15, 8, 8);
            bodyGeo.scale(1, 0.6, 0.6);
            const mat = new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.9 });
            const body = new THREE.Mesh(bodyGeo, mat);
            group.add(body);
            const headGeo = new THREE.SphereGeometry(0.08, 8, 8);
            const head = new THREE.Mesh(headGeo, mat);
            head.position.set(0.15, 0, 0);
            group.add(head);
            const earGeo = new THREE.SphereGeometry(0.04, 4, 4);
            const earL = new THREE.Mesh(earGeo, mat);
            earL.position.set(0.12, 0.08, 0.05); group.add(earL);
            const earR = earL.clone();
            earR.position.set(0.12, 0.08, -0.05); group.add(earR);
            const tailGeo = new THREE.CylinderGeometry(0.01, 0.005, 0.3);
            tailGeo.rotateZ(Math.PI/2);
            const tail = new THREE.Mesh(tailGeo, new THREE.MeshStandardMaterial({color: 0x111111}));
            tail.position.set(-0.25, 0, 0);
            group.add(tail);
            group.scale.set(2.0, 2.0, 2.0);
            return group;
        }

        function spawnMouse() {
            const m = createMouseMesh();
            m.rotation.y = Math.random() * Math.PI * 2;
            const zPos = camera.position.z - 5 - Math.random()*20;
            m.position.set((Math.random()-0.5)*10, -2.4, zPos);
            m.userData = { vel: new THREE.Vector3((Math.random()-0.5)*0.1, 0, (Math.random()-0.5)*0.1) };
            m.lookAt(m.position.clone().add(m.userData.vel));
            scene.add(m);
            state.mice.push(m);
        }

        function updateMice() {
            for(let i=state.mice.length-1; i>=0; i--) {
                const m = state.mice[i];
                m.position.add(m.userData.vel);
                if(Math.random() < 0.05) { 
                    m.userData.vel.set((Math.random()-0.5)*0.1, 0, (Math.random()-0.5)*0.1);
                    m.lookAt(m.position.clone().add(m.userData.vel));
                }
                if(m.position.distanceTo(camera.position) > 40) {
                    scene.remove(m);
                    state.mice.splice(i, 1);
                }
            }
        }

        function createGhostMesh() {
            const group = new THREE.Group();
            const bodyGeo = new THREE.CylinderGeometry(0.2, 0.5, 1.5, 8, 4, true);
            const pos = bodyGeo.attributes.position;
            for(let i=0; i<pos.count; i++) {
                if(pos.getY(i) < -0.5) {
                    pos.setX(i, pos.getX(i) + (Math.random()-0.5)*0.2);
                    pos.setZ(i, pos.getZ(i) + (Math.random()-0.5)*0.2);
                }
            }
            bodyGeo.computeVertexNormals();
            const mat = new THREE.MeshBasicMaterial({ color: 0xccffcc, transparent: true, opacity: 0.6, side: THREE.DoubleSide, blending: THREE.AdditiveBlending });
            const body = new THREE.Mesh(bodyGeo, mat);
            group.add(body);
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.4, 8, 8), mat);
            head.position.y = 0.7; group.add(head);
            const eyeGeo = new THREE.SphereGeometry(0.05);
            const eyeMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const eyeL = new THREE.Mesh(eyeGeo, eyeMat);
            eyeL.position.set(0.15, 0.75, 0.3); group.add(eyeL);
            const eyeR = eyeL.clone();
            eyeR.position.set(-0.15, 0.75, 0.3); group.add(eyeR);
            return group;
        }

        function spawnGhost() {
            const g = createGhostMesh();
            g.position.set((Math.random()-0.5)*12, -1, camera.position.z - 5 - Math.random()*25);
            g.userData = { life: 0, maxLife: 100 + Math.random()*100, phase: Math.random()*10 };
            g.lookAt(camera.position);
            scene.add(g);
            state.ghosts.push(g);
        }
        
        function spawnJumpScareGhost() {
            const g = createGhostMesh();
            // Spawn right in front of camera
            const spawnPos = new THREE.Vector3(0, -0.5, -1.5).applyMatrix4(camera.matrixWorld);
            g.position.copy(spawnPos);
            g.lookAt(camera.position);
            g.scale.set(1.5, 1.5, 1.5); // Bigger!
            g.userData = { life: 0, maxLife: 100, phase: 0 };
            scene.add(g);
            state.ghosts.push(g);
            playSound('unlock'); // Scream sound substitute
        }

        function updateGhosts() {
            for(let i=state.ghosts.length-1; i>=0; i--) {
                const g = state.ghosts[i];
                g.userData.life++;
                g.position.y += 0.015; 
                g.position.x += Math.sin(g.userData.life * 0.05 + g.userData.phase) * 0.01;
                g.lookAt(camera.position);
                const prog = g.userData.life / g.userData.maxLife;
                const opacity = (prog < 0.2) ? prog * 2 : (prog > 0.7 ? (1-prog)*2 : 0.6);
                g.children.forEach(c => { if(c.material.transparent) c.material.opacity = opacity; });
                if(g.userData.life > g.userData.maxLife) {
                    scene.remove(g);
                    state.ghosts.splice(i, 1);
                }
            }
        }

        function spawnMagicParticles(pos) {
            const pGeo = new THREE.BufferGeometry();
            const pCount = 100; // More particles
            const pPos = new Float32Array(pCount * 3);
            for(let j=0; j<pCount*3; j++) pPos[j] = (Math.random()-0.5)*4;
            pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
            const mat = new THREE.PointsMaterial({ color: 0x00ffff, size: 0.1, transparent: true, blending: THREE.AdditiveBlending });
            const ps = new THREE.Points(pGeo, mat);
            ps.position.copy(pos);
            scene.add(ps);
            
            let frames = 0;
            const anim = () => {
                frames++;
                ps.rotation.y += 0.05;
                ps.scale.multiplyScalar(1.02);
                mat.opacity -= 0.01;
                if(frames < 100) requestAnimationFrame(anim);
                else { scene.remove(ps); mat.dispose(); pGeo.dispose(); }
            };
            anim();
        }
        
        function triggerStrongMagic() {
            document.getElementById('magic-flash').style.opacity = 1;
            setTimeout(() => { document.getElementById('magic-flash').style.opacity = 0; }, 500);
            playSound('unlock'); // Re-use unlock sound for impact
        }

        function explodeEnemies() {
            triggerStrongMagic(); // Intense flash!

            const particleMat = new THREE.PointsMaterial({ color: 0xff0000, size: 0.1 });
            const explode = (pos) => {
                const pGeo = new THREE.BufferGeometry();
                const pCount = 50;
                const pPos = new Float32Array(pCount * 3);
                for(let j=0; j<pCount*3; j++) pPos[j] = (Math.random()-0.5)*2;
                pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
                const ps = new THREE.Points(pGeo, particleMat);
                ps.position.copy(pos);
                scene.add(ps);
                let frames = 0;
                const anim = () => {
                    frames++;
                    ps.material.opacity -= 0.02;
                    ps.scale.multiplyScalar(1.05);
                    if(frames < 50) requestAnimationFrame(anim);
                    else scene.remove(ps);
                };
                anim();
            };
            state.mice.forEach(m => { explode(m.position); scene.remove(m); });
            state.ghosts.forEach(g => { explode(g.position); scene.remove(g); });
            state.mice = [];
            state.ghosts = [];
            playSound('boom');
        }

        // --- 3D SCENE SETUP ---
        const shadowCasterMat = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.0, side: THREE.DoubleSide });
        const shadowCasterMesh = new THREE.Mesh(new THREE.PlaneGeometry(0.8,0.8), shadowCasterMat);
        shadowCasterMesh.customDepthMaterial = new THREE.MeshDepthMaterial({ depthPacking: THREE.RGBADepthPacking, map: drawingTexture, alphaTest: 0.5 });
        shadowCasterMesh.castShadow = true;
        camera.add(shadowCasterMesh);

        const plateGroup = new THREE.Group();
        plateGroup.add(new THREE.Mesh(new THREE.BoxGeometry(0.8,0.8,0.02), new THREE.MeshStandardMaterial({color:0xffffff, roughness:0.3})));
        const plateDraw = new THREE.Mesh(new THREE.PlaneGeometry(0.8,0.8), new THREE.MeshStandardMaterial({map:drawingTexture, transparent:true, side:THREE.DoubleSide}));
        plateDraw.position.z = 0.011; plateGroup.add(plateDraw);
        const frame = new THREE.Mesh(new THREE.BoxGeometry(0.84,0.84,0.015), new THREE.MeshStandardMaterial({color:0x111}));
        frame.position.z = -0.01; plateGroup.add(frame);
        plateGroup.position.set(0, -2.0, -0.6);
        camera.add(plateGroup);
        scene.add(camera);

        const torchLight = new THREE.SpotLight(0xff9955, 3.0, 100, Math.PI/3, 0.4, 0.2);
        torchLight.position.set(0,0,0.1); torchLight.target.position.set(0,0,-10); camera.add(torchLight.target); camera.add(torchLight);
        torchLight.castShadow = true; torchLight.shadow.mapSize.width = 1024; torchLight.shadow.mapSize.height = 1024;

        const torchGroup = new THREE.Group();
        torchGroup.add(new THREE.Mesh(new THREE.CylinderGeometry(0.02,0.02,0.25,8), new THREE.MeshStandardMaterial({color:0x4a3c31})));
        const head = new THREE.Mesh(new THREE.CylinderGeometry(0.04,0.02,0.08,8), new THREE.MeshStandardMaterial({color:0x222}));
        head.position.y = 0.15; torchGroup.add(head);
        
        const fireGeo = new THREE.BufferGeometry();
        const firePos = new Float32Array(90); const fireSizes = new Float32Array(30);
        for(let i=0; i<30; i++) { firePos[i*3]=(Math.random()-0.5)*0.05; firePos[i*3+1]=Math.random()*0.1; firePos[i*3+2]=(Math.random()-0.5)*0.05; fireSizes[i]=Math.random(); }
        fireGeo.setAttribute('position', new THREE.BufferAttribute(firePos, 3));
        fireGeo.setAttribute('size', new THREE.BufferAttribute(fireSizes, 1));
        const fireSystem = new THREE.Points(fireGeo, new THREE.PointsMaterial({size:0.05, color:0xffaa00, transparent:true, opacity:0.8, blending:THREE.AdditiveBlending}));
        fireSystem.position.y = 0.22; torchGroup.add(fireSystem); state.torchFlameParticles = fireSystem;
        torchGroup.position.set(-0.35, -0.35, -0.4); torchGroup.rotation.x = -Math.PI/6; torchGroup.rotation.z = -Math.PI/8;
        camera.add(torchGroup);

        const lantern = new THREE.PointLight(0xffbb77, 0.8, 20); lantern.position.set(0,0.5,0); camera.add(lantern);
        const globalAmbient = new THREE.AmbientLight(0x050510, 0.02);
        scene.add(globalAmbient);

        function createStoneTexture() {
            const c = document.createElement('canvas'); c.width = 512; c.height = 512; const cx = c.getContext('2d');
            cx.fillStyle = "#1a1a1e"; cx.fillRect(0,0,512,512); 
            for(let i=0; i<40000; i++) { cx.fillStyle = Math.random()>0.5?"rgba(0,0,0,0.2)":"rgba(255,255,255,0.02)"; cx.fillRect(Math.random()*512, Math.random()*512, 2, 2); }
            cx.strokeStyle = "rgba(0,0,0,0.5)"; cx.lineWidth = 4;
            for(let y=0; y<512; y+=128) { let off=(y/128%2)*64; for(let x=-64; x<512; x+=128) cx.strokeRect(x+off, y, 128, 128); }
            return c.toDataURL();
        }
        const stoneMap = new THREE.TextureLoader().load(createStoneTexture());
        stoneMap.wrapS = stoneMap.wrapT = THREE.RepeatWrapping; stoneMap.repeat.set(4,4);
        
        const room = new THREE.Mesh(new THREE.BoxGeometry(12,10,100), new THREE.MeshStandardMaterial({map:stoneMap, roughness:0.9, side:THREE.BackSide}));
        room.position.set(0,2,-48); room.scale.set(-1,1,1); room.receiveShadow = true; scene.add(room);
        const floor = new THREE.Mesh(new THREE.PlaneGeometry(12,100), new THREE.MeshStandardMaterial({map:stoneMap, roughness:0.8}));
        floor.rotation.x = -Math.PI/2; floor.position.set(0,-2.5,-48); floor.receiveShadow = true; scene.add(floor);

        const pGeo = new THREE.BoxGeometry(1.5,10,1.5); const pMat = new THREE.MeshStandardMaterial({map:stoneMap, color:0x333333});
        for(let z=-10; z>-90; z-=15) {
            let p1 = new THREE.Mesh(pGeo, pMat); p1.position.set(-5,2,z); p1.castShadow=true; scene.add(p1);
            let p2 = new THREE.Mesh(pGeo, pMat); p2.position.set(5,2,z); p2.castShadow=true; scene.add(p2);
            let b = new THREE.Mesh(new THREE.BoxGeometry(12,1.5,1.5), pMat); b.position.set(0,6,z); b.castShadow=true; scene.add(b);
        }

        const dustGeo = new THREE.BufferGeometry(); const dustPos = new Float32Array(2400);
        for(let i=0; i<2400; i+=3) { dustPos[i]=(Math.random()-0.5)*10; dustPos[i+1]=(Math.random()-0.5)*6; dustPos[i+2]=-Math.random()*40; }
        dustGeo.setAttribute('position', new THREE.BufferAttribute(dustPos, 3));
        const dustSystem = new THREE.Points(dustGeo, new THREE.PointsMaterial({size:0.05, color:0x555555, transparent:true, opacity:0.3}));
        scene.add(dustSystem);

        let currentDoorObj = null;
        function createDoor(zPos, runeType, lines) {
            const levelData = CONSTELLATIONS[runeType];
            const hint = levelData ? levelData.hint : "æœªçŸ¥æŒ‘æˆ°";
            
            const g = new THREE.Group(); g.position.set(0, -2.5, zPos);
            g.userData = { isDoorGroup: true }; // Tag for cleanup
            const frame = new THREE.Mesh(new THREE.BoxGeometry(5,6,1), new THREE.MeshStandardMaterial({color:0x111}));
            frame.position.y=3; frame.castShadow=true; frame.receiveShadow=true; g.add(frame);
            const door = new THREE.Mesh(new THREE.PlaneGeometry(4,5), new THREE.MeshStandardMaterial({color:0x332211}));
            door.position.set(0,3,0.51); door.receiveShadow=true; g.add(door);
            
            const rc = document.createElement('canvas'); rc.width=256; rc.height=256; const ctx=rc.getContext('2d');
            
            // Simplified Black Text Rendering
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillStyle = "#000000"; // Solid Black
            
            // Draw Hint - Small
            ctx.font = '24px "Microsoft JhengHei"'; 
            ctx.fillStyle = "#000000";
            ctx.fillText(hint, 128, 100); // Moved to a more central position
            
            // Draw "ä¹‹é–€" - Large
            ctx.font = '32px "Microsoft JhengHei"'; 
            ctx.fillText("ä¹‹é–€", 128, 160); // Moved to a more central position

            // Draw generic background stars
            ctx.fillStyle = "rgba(0, 0, 0, 0.1)"; 
            for(let i=0; i<12; i++) {
                ctx.beginPath();
                ctx.arc(Math.random()*256, Math.random()*256, 1.5, 0, Math.PI*2);
                ctx.fill();
            }
            
            const rune = new THREE.Mesh(new THREE.PlaneGeometry(2.5,2.5), new THREE.MeshBasicMaterial({map:new THREE.CanvasTexture(rc), transparent:true, blending:THREE.NormalBlending}));
            rune.position.set(0,3,0.52); g.add(rune);
            return { group:g, door:door };
        }

        // --- CONTROLS ---
        let isDragView = false; let prevMouse = { x: 0, y: 0 }; let camRot = { x: 0, y: 0 };
        const STAND_HEIGHT = 1.7; const GRAVITY = -0.015; const JUMP_FORCE = 0.35;

        document.addEventListener('mousedown', (e) => { 
            if(e.target.closest('.btn') || e.target.closest('#slider-container') || e.target.closest('.move-btn') || e.target.closest('.jump-btn') || state.drawingMode || e.target.id === 'btn-exit') return;
            
            if (state.currentLevel === 3 && state.grailMesh) {
                const mouse = new THREE.Vector2( (e.clientX/window.innerWidth)*2-1, -(e.clientY/window.innerHeight)*2+1 );
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObject(state.grailMesh, true);
                if (intersects.length > 0) {
                    claimVictory();
                    return;
                }
            }

            isDragView = true; prevMouse.x = e.clientX; prevMouse.y = e.clientY; 
        });
        document.addEventListener('mousemove', (e) => { 
            if(isDragView && !state.levitating) { 
                camRot.y -= (e.clientX-prevMouse.x)*0.003; camRot.x -= (e.clientY-prevMouse.y)*0.003; camRot.x = Math.max(-0.6, Math.min(0.6, camRot.x)); camera.rotation.order="YXZ"; camera.rotation.y=camRot.y; camera.rotation.x=camRot.x; prevMouse.x=e.clientX; prevMouse.y=e.clientY; 
            } 
        });
        document.addEventListener('mouseup', () => isDragView = false);
        document.addEventListener('keydown', (e) => { 
            if(state.drawingMode || state.levitating) return;
            if(e.code==='KeyW') state.moveForward=true; if(e.code==='KeyS') state.moveBackward=true;
            if(e.code==='Space') { if(state.onGround) jump(); else togglePlate(); }
            if(e.code==='KeyF') toggleTorch(); if(e.code==='KeyE') openDrawingModal();
        });
        document.addEventListener('keyup', (e) => { if(e.code==='KeyW') state.moveForward=false; if(e.code==='KeyS') state.moveBackward=false; });

        const setupBtn = (id, dn, up) => { const b=document.getElementById(id); b.addEventListener('mousedown', dn); b.addEventListener('mouseup', up); b.addEventListener('touchstart', (e)=>{e.preventDefault();dn();}); b.addEventListener('touchend', (e)=>{e.preventDefault();up();}); };
        setupBtn('btn-forward', ()=>state.moveForward=true, ()=>state.moveForward=false);
        setupBtn('btn-backward', ()=>state.moveBackward=true, ()=>state.moveBackward=false);
        setupBtn('btn-jump', jump, ()=>{});

        const btnTorch=document.getElementById('btn-torch'), btnPlate=document.getElementById('btn-plate'), btnDraw=document.getElementById('btn-draw');
        btnTorch.classList.add('active');
        btnTorch.addEventListener('click', toggleTorch); btnPlate.addEventListener('click', togglePlate); btnDraw.addEventListener('click', openDrawingModal);
        document.getElementById('arm-slider').addEventListener('input', (e)=>{state.armExtension=parseFloat(e.target.value); playSound('slide'); validateShadow();});
        document.getElementById('btn-modal-done').addEventListener('click', closeDrawingModal);
        document.getElementById('btn-modal-clear').addEventListener('click', ()=>{clearCanvas(); playSound('click');});
        
        let currentUser = "";

        document.getElementById('start-btn').addEventListener('click', () => { 
            const info = document.getElementById('student-info').value.trim();
            if(!info) {
                alert("è«‹è¼¸å…¥ç­åˆ¥å­¸è™Ÿï¼");
                return;
            }
            currentUser = info;
            document.getElementById('intro').style.display = 'none'; 
            document.getElementById('tutorial-modal').style.display = 'flex'; // Show tutorial after intro
            requestAnimationFrame(animateTutorial); // Start tutorial animation
        });

        document.getElementById('btn-tutorial-start').addEventListener('click', () => {
            document.getElementById('tutorial-modal').style.display = 'none';
            state.levels = getRandomLevels();
            state.levels.push({ name: "è–æ¯", type: 'win', lines: [] });
            const z=state.levelZ[0];
            currentDoorObj = createDoor(z, state.levels[0].type, state.levels[0].lines);
            scene.add(currentDoorObj.group);
            state.startTime = Date.now();
            state.gameActive = true;
            if(audioCtx.state === 'suspended') audioCtx.resume(); 
            playSound('click'); 
        });

        window.resetGameToHome = function() {
            window.location.href = '../index.html';
        }

        window.playAgainSameUser = function() {
            document.getElementById('victory-screen').style.display = 'none';
            resetGame();
            // Start the game immediately
            document.getElementById('start-btn').click();
        }

        window.playAgainNewUser = function() {
            document.getElementById('victory-screen').style.display = 'none';
            document.getElementById('student-info').value = "";
            currentUser = "";
            resetGame();
        }

        document.getElementById('restart-btn').addEventListener('click', playAgainSameUser);
        document.getElementById('btn-exit').addEventListener('click', resetGameToHome);
        document.getElementById('btn-fact-continue').addEventListener('click', () => {
            document.getElementById('fact-modal').style.display = 'none';
            state.gameActive = true;
            const d=currentDoorObj.group; let i=0;
            const anim = setInterval(()=>{ d.position.y+=0.05; i++; if(i>100) { clearInterval(anim); document.getElementById('message-overlay').style.opacity=0; nextLevel(); } }, 16);
        });

        function jump() { if(state.onGround) { state.velocity.y=JUMP_FORCE; state.onGround=false; playSound('jump'); } }
        function toggleTorch(forceState) { 
            if (typeof forceState === 'boolean') state.torchOn = forceState; else state.torchOn = !state.torchOn;
            torchLight.visible=state.torchOn; lantern.visible=state.torchOn; if(state.torchFlameParticles) state.torchFlameParticles.visible=state.torchOn; btnTorch.classList.toggle('active',state.torchOn); playSound('click'); validateShadow(); 
        }
        function togglePlate(force) { 
            if(typeof force === 'boolean') state.plateUp = force; else state.plateUp=!state.plateUp; 
            btnPlate.classList.toggle('active',state.plateUp); document.getElementById('match-display').style.display=state.plateUp?'block':'none'; playSound('click'); validateShadow(); 
        }
        function openDrawingModal() { togglePlate(false); state.drawingMode=true; document.getElementById('drawing-modal').style.display='flex'; updateReferenceShape(); playSound('click'); }
        function closeDrawingModal() { state.drawingMode=false; document.getElementById('drawing-modal').style.display='none'; playSound('click'); validateShadow(); }

        function claimVictory() {
            state.gameActive = false;
            state.levitating = true;
            playSound('win');
            document.getElementById('white-flash').style.opacity = 1;
            const totalTime = Date.now() - state.startTime;
            saveTime(totalTime);
            document.getElementById('final-time').innerText = "æ™‚é–“: " + formatTime(totalTime);
            setTimeout(() => {
                document.getElementById('victory-screen').style.display = 'flex';
                document.getElementById('white-flash').style.opacity = 0;
            }, 3000);
        }

        function createTreasure() {
            const g = new THREE.Group(); g.position.set(0,-2.5,-60);
            g.userData = { isTreasureGroup: true };
            const cGeo = new THREE.CylinderGeometry(0.1,0.1,0.02,8);
            const cMat = new THREE.MeshStandardMaterial({color:0xffd700, metalness:1, roughness:0.2});
            for(let i=0; i<3000; i++) {
                const c = new THREE.Mesh(cGeo, cMat);
                c.position.set((Math.random()-0.5)*12, Math.random()*1.5, (Math.random()-0.5)*10);
                c.rotation.set(Math.random()*3, Math.random()*3, Math.random()*3);
                g.add(c);
            }
            const gemGeo = new THREE.OctahedronGeometry(0.15);
            const gemCols = [0xff0000, 0x00ff00, 0x0000ff, 0xff00ff, 0x00ffff];
            for(let i=0; i<50; i++) {
                const gm = new THREE.Mesh(gemGeo, new THREE.MeshStandardMaterial({color: gemCols[Math.floor(Math.random()*gemCols.length)], emissive: 0x333333, metalness: 0.5, roughness: 0.1}));
                gm.position.set((Math.random()-0.5)*10, 0.5 + Math.random()*0.5, (Math.random()-0.5)*8);
                g.add(gm);
            }
            const grailGroup = new THREE.Group();
            grailGroup.position.set(0, 1.5, 0);
            const cup = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.2, 0.5, 16, 1, true), new THREE.MeshStandardMaterial({color:0xffd700, metalness:1, roughness:0.1, side:THREE.DoubleSide}));
            cup.position.y = 0.5; grailGroup.add(cup);
            const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.5, 8), new THREE.MeshStandardMaterial({color:0xffd700, metalness:1}));
            stem.position.y = 0; grailGroup.add(stem);
            const base = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.4, 0.1, 16), new THREE.MeshStandardMaterial({color:0xffd700, metalness:1}));
            base.position.y = -0.25; grailGroup.add(base);
            const gl = new THREE.PointLight(0xffffaa, 1, 5); gl.position.y=0.8; grailGroup.add(gl);
            const haloGeo = new THREE.RingGeometry(0.6, 0.7, 32);
            const haloMat = new THREE.MeshBasicMaterial({ color: 0xffff00, side: THREE.DoubleSide, transparent: true, opacity: 0.5, blending: THREE.AdditiveBlending });
            const halo = new THREE.Mesh(haloGeo, haloMat);
            halo.position.y = 0.5; grailGroup.add(halo);
            const hitbox = new THREE.Mesh(new THREE.BoxGeometry(1,1.5,1), new THREE.MeshBasicMaterial({visible:false}));
            hitbox.userData = { isGrail: true };
            grailGroup.add(hitbox);
            state.grailMesh = hitbox; 
            const animateGrail = () => {
                grailGroup.rotation.y += 0.01;
                grailGroup.position.y = 1.5 + Math.sin(Date.now()*0.002)*0.2;
                halo.lookAt(camera.position); 
                requestAnimationFrame(animateGrail);
            };
            animateGrail();
            g.add(grailGroup);
            scene.add(g);
        }

        function distToSegmentSquared(p, v, w) {
            const l2 = (v.x - w.x)**2 + (v.y - w.y)**2;
            if (l2 === 0) return (p.x - v.x)**2 + (p.y - v.y)**2;
            let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
            t = Math.max(0, Math.min(1, t));
            return (p.x - (v.x + t * (w.x - v.x)))**2 + (p.y - (v.y + t * (w.y - v.y)))**2;
        }

        function validateShadow() {
            if(state.levelTransition || !state.torchOn || !state.plateUp || state.currentLevel>=3) return;
            const w=512; const h=512; const step=10; 
            const img=ctx.getImageData(0,0,w,h).data;
            const doorZ = state.levelZ[state.currentLevel];
            const currentLevelData = state.levels[state.currentLevel];
            
            // Ensure refData is ready for the current type
            if (!refData || state.lastRefType !== currentLevelData.type) {
                prepareRefData(currentLevelData.type);
                state.lastRefType = currentLevelData.type;
            }

            const mag = Math.abs(camera.position.z - (doorZ+0.52)) / (state.armExtension+0.01);
            
            const targetPos = new THREE.Vector3(0, 0.5, doorZ); targetPos.project(camera);
            const alignDist = Math.sqrt(targetPos.x**2 + targetPos.y**2);
            
            // Extremely generous alignment factor
            let alignFactor = 1.0; 
            if(alignDist > 0.6) alignFactor = Math.max(0.5, 1.0 - (alignDist-0.6));

            let misses = 0;
            const pxToNorm = 1.0 / 256.0; 
            const hitMap = new Set(); // Track UNIQUE target pixels hit

            for(let y=0; y<h; y+=step) {
                for(let x=0; x<w; x+=step) {
                    if(img[(y*w+x)*4+3]>150) {
                        const u = (x - 256) * pxToNorm * mag * 0.4;
                        const v = -(y - 256) * pxToNorm * mag * 0.4;
                        
                        const rx = Math.floor((u / 1.25) * 256 + 256);
                        const ry = Math.floor((-v / 1.25) * 256 + 256);
                        
                        if (rx >= 0 && rx < 512 && ry >= 0 && ry < 512) {
                            if (refData[(ry * 512 + rx) * 4] > 128) {
                                // Record hit on a 10px grid to match refPixelCount logic
                                const gridKey = Math.floor(ry/10) * 100 + Math.floor(rx/10);
                                hitMap.add(gridKey); 
                            } else {
                                misses++;
                            }
                        } else {
                            misses++;
                        }
                    }
                }
            }

            const uniqueHits = hitMap.size;
            
            // Coverage: Target coverage score - 10% easier
            const coverage = Math.min(1.0, uniqueHits / Math.max(1, state.refPixelCount * 0.45)); 
            
            // Precision: Reduced penalty for misses (2.5 -> 2.0)
            const precision = uniqueHits / Math.max(1, uniqueHits + misses * 2.0); 

            // Density Check: Slightly more lenient (4x -> 5x)
            const totalShadowPixels = uniqueHits + misses;
            let densityFactor = 1.0;
            if (totalShadowPixels > uniqueHits * 5) densityFactor = 0.6;

            // Calculate raw score
            let rawScore = (coverage * 0.5 + precision * 0.5) * 100 * densityFactor;
            
            // Final adjustments
            let finalScore = Math.min(100, Math.floor(rawScore * alignFactor));

            const md = document.getElementById('match-display');
            md.innerText = `å¥‘åˆåº¦: ${finalScore}%`;
            md.style.color = finalScore<45?'#ff4444':(finalScore<60?'#ffff00':'#00ff00');
            
            // Pass threshold lowered to 60%
            if(finalScore >= 50) levelComplete();
        }

        function levelComplete() {
            if(state.levelTransition) return; state.levelTransition=true;
            document.getElementById('message-overlay').style.opacity=1; playSound('unlock');
            
            spawnMagicParticles(new THREE.Vector3(0, 0.5, state.levelZ[state.currentLevel] + 1));

            setTimeout(() => {
                state.gameActive = false; 
                const level = state.levels[state.currentLevel];
                document.getElementById('fact-title').innerText = level.name;
                document.getElementById('fact-text').innerText = level.fact;
                const factCanvas = document.getElementById('fact-canvas');
                const factCtx = factCanvas.getContext('2d');
                drawConstellation(factCtx, 250, 250, level.lines, "#ffaa00", true, level.symbol, true); 
                document.getElementById('fact-modal').style.display = 'flex';
            }, 1000);
        }

        function nextLevel() {
            if(state.currentLevel>=3) return;
            
            // Cleanup the previous door before adding a new one
            if(currentDoorObj) {
                scene.remove(currentDoorObj.group);
                currentDoorObj = null;
            }
            
            state.currentLevel++; state.levelTransition=false; clearCanvas(); document.getElementById('match-display').innerText="å¥‘åˆåº¦: 0%";
            if(state.currentLevel === 2) { 
                toggleTorch(false); 
                playSound('torch_off'); 
                globalAmbient.intensity = 0.005; 
                setTimeout(spawnJumpScareGhost, 300); // Trigger jump scare shortly after lights out
            }
            if (state.currentLevel === 3) explodeEnemies();

            if(state.currentLevel<3) {
                const z=state.levelZ[state.currentLevel];
                currentDoorObj = createDoor(z, state.levels[state.currentLevel].type, state.levels[state.currentLevel].lines);
                scene.add(currentDoorObj.group);
            } else {
                createTreasure();
            }
        }

        // --- GAME LOOP & EVENTS ---
        let frameCount=0;
        function animate() {
            requestAnimationFrame(animate); frameCount++;
            updateTimer();

            if (state.levitating) {
                camera.position.y += 0.05; camera.rotation.y += 0.01; renderer.render(scene, camera); return;
            }

            if(!state.onGround) {
                state.velocity.y += GRAVITY; camera.position.y += state.velocity.y;
                if(camera.position.y <= STAND_HEIGHT) { camera.position.y=STAND_HEIGHT; state.velocity.y=0; state.onGround=true; }
            }

            if(state.gameActive && !state.haunting) {
                const speed = 0.15;
                const doorZ = state.currentLevel<3 ? state.levelZ[state.currentLevel] : -999;
                const backLimit = state.currentLevel === 0 ? 5.0 : 0.5;
                if(state.moveForward && camera.position.z > doorZ+4) camera.position.z -= speed;
                if(state.moveBackward && camera.position.z < backLimit) camera.position.z += speed;
                
                if (state.currentLevel === 3) {
                    const dist = new THREE.Vector2(camera.position.x, camera.position.z).distanceTo(new THREE.Vector2(0, -60));
                    if (dist < 2.0) claimVictory();
                }
            }

            if(frameCount%5===0 && state.gameActive) validateShadow();

            if(state.currentLevel===1 && Math.random()<0.01) spawnMouse(); updateMice();
            if(state.currentLevel===2) { if(Math.random()<0.01) spawnGhost(); updateGhosts(); }

            const targetPos = state.plateUp ? new THREE.Vector3(0, -0.7+(camera.position.y-STAND_HEIGHT)*0.5, -state.armExtension) : new THREE.Vector3(0.3, -2.0, -0.5);
            plateGroup.position.lerp(targetPos, 0.1);
            plateGroup.rotation.x = THREE.MathUtils.lerp(plateGroup.rotation.x, state.plateUp?0:1.0, 0.1);
            if(state.plateUp) { shadowCasterMesh.position.set(0, 0, -state.armExtension); shadowCasterMesh.scale.set(1,1,1); } else { shadowCasterMesh.scale.set(0,0,0); }

            if(state.torchOn) torchLight.intensity = 3.0 + Math.random()*0.15;
            if(state.torchFlameParticles) {
                const pos = state.torchFlameParticles.geometry.attributes.position.array;
                for(let i=0; i<30; i++) { pos[i*3+1]+=0.005+Math.random()*0.005; if(pos[i*3+1]>0.15) { pos[i*3+1]=0; pos[i*3]=(Math.random()-0.5)*0.04; pos[i*3+2]=(Math.random()-0.5)*0.04; } }
                state.torchFlameParticles.geometry.attributes.position.needsUpdate=true;
            }
            const dPos = dustSystem.geometry.attributes.position.array;
            for(let i=0; i<dPos.length; i+=3) { dPos[i+1]-=0.005; if(dPos[i+1]<-3) dPos[i+1]=3; }
            dustSystem.geometry.attributes.position.needsUpdate=true; dustSystem.position.z=camera.position.z;

            renderer.render(scene, camera);
        }
        animate();
        window.addEventListener('resize', () => { camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
    </script>
</body>
</html>